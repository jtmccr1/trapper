{"version":3,"sources":["images/logo.png","lib/outbreak/Case.js","lib/outbreak/Link.js","utils/commonFunctions.js","components/Header.js","lib/figtree.js/tree.js","lib/charts/d3Plot.js","lib/charts/stackedHistogram.js","lib/figtree.js/layout.js","lib/figtree.js/rectangularLayout.js","lib/figtree.js/transmissionLayout.js","lib/figtree.js/arcLayout.js","lib/figtree.js/bauble.js","lib/figtree.js/figtree.js","lib/figtree.js/Graph.js","lib/charts/d3PlotLayout.js","lib/charts/stackedHistogramLayout.js","components/StackedHistogram.js","components/PhyloChart.js","lib/outbreak/Outbreak.js","lib/charts/fishplotLayout.js","lib/charts/areaPlot.js","lib/outbreak/Epidemic.js","components/AreaPlot.js","components/ArcTransmission.js","components/ObjectChart.js","lib/charts/axis.js","components/TimeAxis.js","components/ChartContainer.js","components/LineList.js","components/Geography.js","utils/dataParsers.js","components/App.js","serviceWorker.js","index.js"],"names":["module","exports","__webpack_require__","p","Case","data","keyMap","arguments","length","undefined","Map","Object","classCallCheck","this","dataMap","concat","toConsumableArray","DEFAULT_MAP","symptomOnset","get","sampleDate","resolution","resoultionDate","id","location","caseId","Symbol","keys","filter","k","values","indexOf","metadata","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","iterator","next","done","key","value","err","return","Date","valueOf","map","d","resolutionDate","Link","target","source","dataSource","dateParse","timeParse","Header","react_default","a","createElement","className","href","rel","src","logo","alt","width","style","marginTop","marginBottom","fontSize","Type","DISCRETE","BOOLEAN","INTEGER","FLOAT","PROBABILITIES","Tree","_this","rootNode","root","annotations","nodeList","preorder","forEach","node","index","label","startsWith","substring","addAnnotations","nodeMap","tipMap","externalNodes","tip","name","nodeLabelMap","internalNodes","treeUpdateCallback","createClass","parent","children","find","child","regenerator_default","mark","traverse","wrap","_context2","prev","_context","delegateYield","t1","finish","stop","postorder","_context4","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","_context3","_this2","toNewick","join","_this3","proportion","rootLength","node0","lineage","nodeAtTop","rootChild1","rootChild2","oldLength","sibling","getSibling","push","_ref","l","recursive","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","rotate","reverse","increasing","orderNodes","callback","factor","count","counts","_iteratorNormalCompletion6","_didIteratorError6","_iteratorError6","_step6","_iterator6","set","sort","b","call","node1","node2","path1","pathToRoot","path2","n1","n2","reduce","acc","curr","level","sum","mrca","lastCommonAncestor","_i","_arr","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_step4","_iterator4","_this4","rootToTipLength","_this5","splits","splitNode","_ref2","_ref3","slicedToArray","time","splitBranch","splitLocation","midpoint","_i2","_Object$entries","entries","_ref6","_ref5","getExternalNode","Error","annotateNode","_i3","_Object$entries2","_ref9","_ref8","getNode","_i4","_Object$entries3","_ref12","_ref11","getNodeFromLabel","_i5","_Object$entries4","_ref15","_ref14","objectSpread","datum","_i6","_Object$entries5","_ref18","_ref17","addValues","annotation","String","Array","isArray","type","isExtensible","_i7","_Object$entries6","_ref21","_ref20","includes","isNaN","Set","add","acctran","fitchParsimony","I","U","childStates","state","reconstructInternalStates","parentStates","nodeStates","stateCounts","max","current","_ref22","_ref23","_ref24","_ref25","nodes","_context5","newickString","labelName","datePrefix","tokens","split","currentNode","nodeStack","labelNext","lengthNext","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_step5","_iterator5","token","pop","parseFloat","substr","endsWith","trim","date","parts","externalNode","d3Plot","svg","layout","margins","settings","DEFAULT_SETTINGS","tranitionDuration","xScaleType","scaleLinear","yScaleType","yAxisType","axisLeft","xAxisType","axisBottom","height","getBoundingClientRect","select","remove","append","attr","left","top","svgSelection","addDataLayers","xScale","domain","horizontalRange","range","right","yScale","verticalRange","bottom","scales","x","y","addAxis","updateCallback","update","action","selection","selected","selectAll","on","i","n","enter","exit","renderText","tooltip","document","getElementById","innerHTML","display","event","pageX","pageY","visibility","axesLayer","tickValues","horizontalAxisTicks","ticks","transition","duration","transitionDuration","ease","easeLinear","x0","x1","axisBoxes","_ref4","stackedHistogramChart","_d3Plot","possibleConstructorReturn","getPrototypeOf","inherits","hoverBorder","backgroundBorder","baubles","bins","rects","c","v","getAnnotations","Math","y1","y0","updateAxis","Layout","_horizontalRange","_verticalRange","_horizontalTicks","vertices","edges","vertex","tree","edge","position","reroot","v1","text","RectangularLayout","_Layout","branchLabelAnnotationName","internalNodeLabelAnnotationName","externalNodeLabelAnnotationName","lengthFormat","format","branchCurve","curveStepBefore","horizontalScale","rootToTipLengths","currentY","setYPosition","degree","classes","isSelected","leftLabel","rightLabel","labelBelow","edgeMap","v0","e","termini","traverseToEnd","tips","t","_ref7","annotationName","mean","line","curve","branchLine","ArcLayout","graph","edgeWidth","xFunction","curveLinear","opacity","locations","getEdges","getOutgoingEdges","dataEdges","metaData","_e$v1$node","noId","objectWithoutProperties","Number","_ref10","points","sign","startingP","endingP","correctingFactor","abs","p0","p1","p2","p3","pow","cubicBezier","r","sqrt","circleY","Bauble","vertexFilter","CircleBauble","_Bauble","radius","border","FigTree","updateStyles","xAxisTickArguments","xAxisTitle","opacityFunc","xAxis","tickArguments","xAxisWidth","newNodes","bauble","createShapes","updateShapes","updateBranches","self","classed","console","log","hilightNodes","x2","mx","mouse","min","onClickNode","nodeId","classString","nodeGroup","nodeShape","raise","_this6","branchesLayer","branchPath","branchPathGenerator","branches","newBranches","Graph","acyclicSelector","outGoingEdgeMap","incomingEdgeMap","edgeList","addNode","drawEdge","has","getIncomingEdges","removeEdge","delete","sourceNodeId","targetNodeId","addEdge","newOutgoing","newIncoming","options","nodesToVisit","outGoingEdges","visited","nextNode","d3PlotLayout","horizontalTicks","params","stackedHistogramLayout","_d3PlotLayout","groupingFunction","binnedFunction","timeWeek","floor","keyToXFunction","offset","dateBins","nest","groupKeys","currentCount","maxCount","_loop","kEntry","w","entry","colorKey","caseEntry","formatTime","timeFormat","StackedHistogram","props","_useState","useState","_useState2","histogram","setHistogram","el","useRef","useEffect","fig","draw","onHover","onClick","alert","rand_id","random","toString","chartGeom","ref","PhyloChart","figtree","setFigtree","dateRangeScale","scaleTime","extent","dateRange","treeRange","treeDateRange","rootToTipScale","phylogeny","hilightInternalNodes","hilightExternalNodes","hilightBranches","Outbreak","cases","addChild","timePoints","tc","totalDescendents","childrenTimeCourse","timeCourse","timePoint","childrenCourses","childrenCases","tp","firstTimePoints","lastTimePoints","childTP","getTime","fishLayout","Epidemic","backgroundOutbreak","rootOutbreak","gapMap","setGapMap","percent","totalCourse","outbreak","timeGap","childrenSpace","chap","innerSpace","numberOfKidGaps","kidGaps","fill","innerSpaceArray","spaceFilled","childOutbreak","parentTop","getStartingDistance","point","total","outbreakId","first0T","first0","lastTP","lastT","smoothingPoint","firstTP","firstT","newFirstTP","totalAtTheTime","easyStart","unshift","setPoints","input_points","apply","parentPoints","areaPlot","curveBasis","areaMaker","area","areas","indexCase","edgeConditionFactory","outbreaks","outbreakMap","edgeCondition","setOutbreaks","firstOutbreak","outbreakTraversal","CaseEdge","parentOutbreak","addCase","startAnotherOutbreak","allAreas","d2","i2","exportEvents","clickHover","shouldSelect","bringBack","getAllCases","o","AreaPlot","plot","setPlot","epidemic","React","forwardRef","branchCallback","support","dataNode","_loop2","terminal","_arr2","nodeCallback","incomingBranches","outGoingBranches","sourceNodes","_arr3","highlightNode","targetNodes","_arr4","thisNode","parentNode","unHighlightNode","_arr5","ArcTransmission","nodeClick","setSelectedCases","selectedCases","onHoverNode","onHoverBranch","XTimeAxis","axisTop","updateAxisBars","TimeAxis","axis","Setaxis","useCallback","layoutSettings","domRect","mouseEnter","timeline","altKey","mouseExit","ChartContainer","setChartGeom","timelineSize","parentBaseDim","every","onMouseMove","onMouseLeave","components_TimeAxis","components_StackedHistogram","Cases","stackedLayout","callbacks","groups","components_AreaPlot","areaLayout","selectArea","components_ArcTransmission","transmissionLayout","components_PhyloChart","LineList","columns","accessor","Cell","filterable","potentialSourcesColumns","potentialTransmissionsColumns","subtableHeader","marginRight","marginLeft","rows","selectedData","s","es","showPagination","defaultPageSize","SubComponent","row","inlinks","original","outlinks","Geography","projection","path","size","mapData","adm0","feature","objects","adm1","adm2","features","m","geoAzimuthalEqualArea","center","scale","translate","geoPath","g","properties","replace","summarizeLinks","d3","links","nestLinks","dataSources","totalObservations","ds","_dataSources","App","optionsOpen","setOptionsOpen","_useState3","_useState4","sideBarOpen","setSideBarOpen","_useState5","_useState6","getTimelineSize","_useState7","_useState8","sideBarFocus","setSideBarFocus","measuredRef","handleResize","resizeTimer","clearTimeout","setTimeout","window","addEventListener","removeEventListener","getSizeAgain","dispatchEvent","Event","prefix","_useState9","_useState10","setPhylogeny","_useState11","_useState12","setDateRange","_useState13","_useState14","setEpidemic","_useState15","_useState16","setTreeDateRange","_useState17","_useState18","mapTopoJSON","setMapTopoJSON","_useState19","_useState20","_useState21","_useState22","setAreaLayout","_useState23","_useState24","setTransmissionLayout","_useState25","_useState26","setStackedLayout","_useFunctionAsState","fn","_useState27","_useState28","val","setVal","useFunctionAsState","_useFunctionAsState2","setArea","setAreaFunc","mostProbableTransphyloEdgeCondition","incomingEdges","maxTransphyloProb","Promise","all","csv","fetch","then","lineList","treeStringPromise","treeAnnotationsPromise","parsedLineList","dataPoint","Outcome","parsedLinks","summarizedLinks","sources","targets","newCase","arr","filtedLinks","outbreakGraph","childLocations","outbreakEpidemic","json","treeString","treeAnnotations","parseNewick","annotateNodesFromLabel","hasOwnProperty","tipLocations","annotateTips","annotateNodesFromTips","order","casesRange","treeMaxTipLength","treeMaxTip","treeMaxDate","treeRootDate","timeDay","totalExtent","week0","weekEnd","ceil","mapResponse","mapJSON","components_Header","index_esm","components_ChartContainer","components_Geography","components_LineList","Boolean","hostname","match","ReactDOM","render","components_App","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.01bc4111.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.a9ecf903.png\";","class Case{\n    /**\n     * A class to hold data for each case. 'case' is a special word in javascript so we spell it with a k.\n     * This class is intended to formalize the data format for each case. The constructor also takes a map which maps   * keys in the incoming object to those in the Case object. Required values in the map and their types are\n     *   symptomOnset     the date of first contact\n     *   sampleDate       an array of dates\n     *   resolution       The resolution of the case\n     *   resolutionDate   The date of resolution\n     * Any incoming keys not mentioned in the dataMap are put in a metadata entry. If the required keys\n     */\n    /**\n     * The constructor\n     * @param data             an object with the following keys. Any other keys will be added to a metadata entry\n     * @param keyMap          a map that maps incoming keys to the required entries above. The defualt assumes the    keys===the entry names. Any entries not provided will be taken from the defualt.\n     *\n     */\n\n    static DEFAULT_MAP() {\n        return new Map([\n            ['symptomOnset','symptomOnset'],\n            ['sampleDate','sampleDate'],\n            ['resolution','resolution'],\n            ['resolutionDate','resolutionDate'],\n            ['id','id'],\n            ['location','location']\n        ]);\n    }\n    constructor(data,keyMap=new Map()){\n        const dataMap = new Map([...Case.DEFAULT_MAP(),...keyMap])\n\n        this.symptomOnset = data[dataMap.get('symptomOnset')]? data[dataMap.get('symptomOnset')] :\"Unknown\";\n        this.sampleDate = data[dataMap.get('sampleDate')]?data[dataMap.get('sampleDate')]:\"Unknown\";\n        this.resolution = data[dataMap.get('resolution')]?data[dataMap.get('resolution')]:\"Unknown\";\n        this.resoultionDate = data[dataMap.get('resolutionDate')]?data[dataMap.get('resolutionDate')]:\"Unknown\";\n        this.id=data[dataMap.get('id')]?data[dataMap.get('id')]:\"Unknown\";\n        this.location = data[dataMap.get('location')]?data[dataMap.get('location')]:\"Unknown\";\n        this.caseId =  Symbol();\n\n        // If there are entries we missed add them here.\n        if(Object.keys(data).filter(k=>[...dataMap.values()].indexOf(k)===-1).length>1){\n            this.metadata={};\n            for(const key of Object.keys(data).filter(k=>[...dataMap.values()].indexOf(k)===-1)){\n\n                this.metadata[key]=data[key];\n            }\n        }\n    }\n\n    /**\n     * Returns a copy of the date of symptomOnset\n     */\n    getSymptomOnset(){\n        return new Date(this.symptomOnset.valueOf());\n    }\n\n    /**\n     * Returns a copy of the sample dates\n     */\n    getSampleDate(){\n        return this.sampleDate.map(d=>new Date(d.valueOf()));\n    }\n\n    /**\n     * Returns a copy of the date of symptomOnset\n     */\n    getResolution(){\n        return this.resolution;\n    }\n\n    /**\n     * Returns a copy of the resolution date\n     */\n    getResolutionDate(){\n        return new Date(this.resolutionDate.valueOf());\n    }\n\n    /**\n     * Returns a copy of the case id\n     */\n    getId(){\n        return this.id;\n    }\n\n    /**\n     * Returns a copy of the unique caseId\n     */\n    getCaseId(){\n        return this.caseId;\n    }\n\n    /**\n     * Returns a copy of the location\n     */\n    getLocation(){\n        return this.location;\n    }\n\n}\n\nexport default Case;","/**\n * A class to hold data for each link.\n * This class is intended to formalize the data format for each case. The constructor also takes a map which maps   * keys in the incoming object to those in the Link object. Required values in the map and their types are\n *   target           the id of the first contact\n *   source              the id of the source\n\n * Any incoming keys not mentioned in the dataMap are put in a metadata entry. If the required keys\n */\nclass Link{\n\n    static DEFAULT_MAP() {\n        return new Map([\n            ['target','target'],\n            ['source','source'],\n            ['dataSource','dataSource'],\n        ]);\n    }\n\n    /**\n     * The constructor\n     * @param data             an object with the following keys. Any other keys will be added to a metadata entry\n     * @param keyMap          a map that maps incoming keys to the required entries above. The defualt assumes the    keys===the entry names. Any entries not provided will be taken from the defualt.\n     *\n     */\n    constructor(data,keyMap=new Map()){\n        const dataMap = new Map([...Link.DEFAULT_MAP(),...keyMap])\n\n        this.target = data[dataMap.get('target')]? data[dataMap.get('target')] :\"Unknown\";\n        this.source = data[dataMap.get('source')]?data[dataMap.get('source')]:\"Unknown\";\n        this.dataSource=data[dataMap.get('dataSource')]?data[dataMap.get('dataSource')]:\"Unknown\";\n        this.metadata={};\n        for(const key of Object.keys(data).filter(k=>[...dataMap.values()].indexOf(k)===-1)){\n            this.metadata[key]=data[key];\n        }\n    }\n\n}\n\nexport default Link;","import{timeParse} from \"d3-time-format\";\nexport const dateParse = timeParse(\"%Y-%m-%d\");\n//https://stackoverflow.com/questions/1053843/get-the-element-with-the-highest-occurrence-in-an-array\nexport function mode(arr){\n    return arr.sort((a,b) =>\n          arr.filter(v => v===a).length\n        - arr.filter(v => v===b).length\n    ).pop();\n}\n","import React from 'react';\nimport logo from '../images/logo.png';\nfunction Header() {\n\t\treturn (\n\t\t\t<div className=\"header\">\n\t\t\t\t<div className=\"logo\">\n\t\t\t\t\t<a href=\"http://artic.network\" target=\"_blank\" rel=\"noopener noreferrer\">\n\t\t\t\t\t\t{/* <img src={logo} alt={'logo'} width=\"132\" /> */}\n\t\t\t\t\t\t<img src={logo} alt={'logo'} width=\"40\" />\n\t\t\t\t\t</a>\n\t\t\t\t</div>\n\t\t\t\t<div className=\"title\">\n\t\t\t\t\t<h2 style={{marginTop: \"0px\", marginBottom: \"8px\"}}>\n\t\t\t\t  \t\t<span style={{fontSize: \"1.8em\"}}>TRAPPER</span>\n\t\t\t\t\t\t<span> Transmission Reconstruction And Phylogenetics Promoting Early Response</span>\n\t\t\t\t\t</h2>\n\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t);\n}\n\nexport default Header;\n","\"use strict\";\n\n/** @module tree */\n\nexport const Type = {\n    DISCRETE : Symbol(\"DISCRETE\"),\n    BOOLEAN : Symbol(\"BOOLEAN\"),\n    INTEGER : Symbol(\"INTEGER\"),\n    FLOAT: Symbol(\"FLOAT\"),\n    PROBABILITIES: Symbol(\"PROBABILITIES\")\n};\n\n/**\n * The Tree class\n */\nexport class Tree {\n    /**\n     * The constructor takes an object for the root node. The tree structure is\n     * defined as nested node objects.\n     *\n     * @constructor\n     * @param {object} rootNode - The root node of the tree as an object.\n     */\n    constructor(rootNode = {}) {\n        this.root = rootNode;\n\n        this.annotations = {};\n\n        this.nodeList = [...this.preorder()];\n        this.nodeList.forEach( (node, index) => {\n            if (node.label && node.label.startsWith(\"#\")) {\n                // an id string has been specified in the newick label.\n                node.id = node.label.substring(1);\n            } else {\n                node.id = `node_${index}`;\n            }\n            this.addAnnotations(node.annotations);\n        });\n        this.nodeMap = new Map(this.nodeList.map( (node) => [node.id, node] ));\n        this.tipMap = new Map(this.externalNodes.map( (tip) => [tip.name, tip] ));\n        this.nodeLabelMap = new Map([...this.internalNodes.map((node)=>[node.label, node]),\n                                    ...this.externalNodes.map( (tip) => [tip.name, tip])]);\n\n        // a callback function that is called whenever the tree is changed\n        this.treeUpdateCallback = () => {};\n    };\n\n    /**\n     * Gets the root node of the Tree\n     *\n     * @returns {Object|*}\n     */\n    get rootNode() {\n        return this.root;\n    };\n\n    /**\n     * Gets an array containing all the node objects\n     *\n     * @returns {*}\n     */\n    get nodes() {\n        return [...this.nodeList];\n    };\n\n    /**\n     * Gets an array containing all the external node objects\n     *\n     * @returns {*}\n     */\n    get externalNodes() {\n        return this.nodes.filter((node) => !node.children);\n    };\n\n    /**\n     * Gets an array containing all the internal node objects\n     *\n     * @returns {*}\n     */\n    get internalNodes() {\n        return this.nodes.filter((node) => node.children );\n    };\n\n    /**\n     * Returns the sibling of a node (i.e., the first other child of the parent)\n     *\n     * @param node\n     * @returns {*}\n     */\n    getSibling(node) {\n        if (!node.parent) {\n            return null;\n        }\n        return node.parent.children.find((child) => child !== node);\n    }\n\n    /**\n     * Returns a node from its id stored.\n     *\n     * @param id\n     * @returns {*}\n     */\n    getNode(id) {\n        return this.nodeMap.get(id);\n    }\n\n    /**\n     * Returns a node from its id stored.\n     *\n     * @param id\n     * @returns {*}\n     */\n    getNodeFromLabel(id) {\n        return this.nodeLabelMap.get(id);\n    }\n\n    /**\n     * Returns an external node (tip) from its name.\n     *\n     * @param name\n     * @returns {*}\n     */\n    getExternalNode(name) {\n        return this.tipMap.get(name);\n    }\n\n    /**\n     * A generator function that returns the nodes in a pre-order traversal.\n     *\n     * @returns {IterableIterator<IterableIterator<*|*>>}\n     */\n    *preorder() {\n        const traverse = function *(node) {\n            yield node;\n            if (node.children) {\n                for (const child of node.children) {\n                    yield* traverse(child);\n                }\n            }\n        };\n\n        yield* traverse(this.root);\n    }\n\n    /**\n     * A generator function that returns the nodes in a post-order traversal\n     *\n     * @returns {IterableIterator<IterableIterator<*|*>>}\n     */\n    *postorder() {\n        const traverse = function *(node) {\n            if (node.children) {\n                for (const child of node.children) {\n                    yield* traverse(child);\n                }\n            }\n            yield node;\n        };\n\n        yield* traverse(this.root);\n    }\n\n    /**\n     * A generator function that returns the nodes in a path to the root\n     *\n     * @returns {IterableIterator<IterableIterator<*|*>>}\n     */\n    static* pathToRoot(node) {\n        while (node) {\n            yield node;\n            node = node.parent;\n        }\n    }\n\n    /**\n     * An instance method to return a Newick format string for the Tree. Can be called without a parameter to\n     * start at the root node. Providing another node will generate a subtree. Labels and branch lengths are\n     * included if available.\n     *\n     * @param {object} node - The node of the tree to be written (defaults as the rootNode).\n     * @returns {string}\n     */\n    toNewick(node = this.rootNode) {\n        return (node.children ? `(${node.children.map(child => this.toNewick(child)).join(\",\")})${node.label ? node.label : \"\"}` : node.name) + (node.length ? `:${node.length}` : \"\");\n    };\n\n    /**\n     * Re-roots the tree at the midway point on the branch above the given node.\n     *\n     * @param {object} node - The node to be rooted on.\n     * @param proportion - proportion along the branch to place the root (default 0.5)\n     */\n    reroot(node, proportion = 0.5) {\n        if (node === this.rootNode) {\n            // the node is the root - nothing to do\n            return;\n        }\n\n        const rootLength = this.rootNode.children[0].length + this.rootNode.children[1].length;\n\n        if (node.parent !== this.rootNode) {\n            // the node is not a child of the existing root so the root is actually changing\n\n            let node0 = node;\n            let parent = node.parent;\n\n            let lineage = [ ];\n\n            // was the node the first child in the parent's children?\n            const nodeAtTop = parent.children[0] === node;\n\n            const rootChild1 = node;\n            const rootChild2 = parent;\n\n            let oldLength = parent.length;\n\n            while (parent.parent) {\n\n                // remove the node that will becoming the parent from the children\n                parent.children = parent.children.filter((child) => child !== node0);\n\n                if (parent.parent === this.rootNode) {\n                    const sibling = this.getSibling(parent);\n                    parent.children.push(sibling);\n                    sibling.length = rootLength;\n                } else {\n                    // swap the parent and parent's parent's length around\n                    [parent.parent.length, oldLength] = [oldLength, parent.parent.length];\n\n                    // add the new child\n                    parent.children.push(parent.parent);\n                }\n\n                lineage = [parent, ...lineage];\n\n                node0 = parent;\n                parent = parent.parent;\n            }\n\n            // Reuse the root node as root...\n\n            // Set the order of the children to be the same as for the original parent of the node.\n            // This makes for a more visually consistent rerooting graphically.\n            this.rootNode.children = nodeAtTop ? [rootChild1, rootChild2] : [rootChild2, rootChild1];\n\n            // connect all the children to their parents\n            this.internalNodes\n                .forEach((node) => {\n                    node.children.forEach((child) => {\n                        child.parent = node;\n                    })\n                });\n\n            const l = rootChild1.length * proportion;\n            rootChild2.length = l;\n            rootChild1.length = rootChild1.length - l;\n\n        } else {\n            // the root is staying the same, just the position of the root changing\n            const l = node.length * (1.0 - proportion);\n            node.length = l;\n            this.getSibling(node).length = rootLength - l;\n        }\n\n        this.treeUpdateCallback();\n    };\n\n    /**\n     * Reverses the order of the children of the given node. If 'recursive=true' then it will\n     * descend down the subtree reversing all the sub nodes.\n     *\n     * @param node\n     * @param recursive\n     */\n    rotate(node, recursive = false) {\n        if (node.children) {\n            if (recursive) {\n                for (const child of node.children) {\n                    this.rotate(child, recursive);\n                }\n            }\n            node.children.reverse();\n        }\n\n        this.treeUpdateCallback();\n    };\n\n    /**\n     * Sorts the child branches of each node in order of increasing or decreasing number\n     * of tips. This operates recursively from the node given.\n     *\n     * @param node - the node to start sorting from\n     * @param {boolean} increasing - sorting in increasing node order or decreasing?\n     * @returns {number} - the number of tips below this node\n     */\n    order(node = this.rootNode, increasing = true) {\n        // orderNodes.call(this, node, increasing, this.treeUpdateCallback);\n        orderNodes.call(this, node, increasing);\n        this.treeUpdateCallback();\n    }\n\n    lastCommonAncestor(node1, node2) {\n\n        const path1 = [...Tree.pathToRoot(node1)];\n        const path2 = [...Tree.pathToRoot(node2)];\n      \n        const sharedAncestors = path1.filter(n1=>path2.map(n2=>n2.id).indexOf(n1.id)>-1);\n        const lastSharedAncestor = sharedAncestors.reduce((acc,curr)=>acc = acc.level>curr.level?acc:curr);\n        return lastSharedAncestor;\n      \n    }\n\n    pathLength(node1, node2) {\n\n        let sum = 0;\n        \n        const mrca = this.lastCommonAncestor(node1,node2);\n        for(let node of [node1,node2]){\n            while(node!=mrca){\n              sum+=node.length;\n              node=node.parent;\n            }\n        }\n        \n        return sum;\n    }\n\n    /**\n     * Gives the distance from the root to a given tip (external node).\n     * @param tip - the external node\n     * @returns {number}\n     */\n    rootToTipLength(tip) {\n        let length = 0.0;\n        for (const node of Tree.pathToRoot(tip)) {\n            if (node.length) {\n                length += node.length;\n            }\n        }\n        return length;\n\n    }\n\n    /**\n     * Returns an array of root-to-tip distances for each tip in the tree.\n     * @returns {*}\n     */\n    rootToTipLengths() {\n        return this.externalNodes.map((tip) => this.rootToTipLength(tip));\n    }\n\n    /**\n     * Splits each branch in multiple segments inserting a new degree 2 nodes. If splitLocations is\n     * null then it splits each in two at the mid-point\n     * @param splits\n     */\n    splitBranches(splits = null) {\n        // split each branch into sections, with a node of\n        // degree two in the middle. This allows annotation\n        // of part of a branch.\n        [...this.preorder()]\n            .filter((node) => node.parent)\n            .forEach((node) => {\n                if (splits !== null) {\n                    if (splits[node.id]) {\n                        let splitNode = node;\n                        splits[node.id].forEach(([time, id]) => {\n                            splitNode = this.splitBranch(splitNode, time);\n                            splitNode.id = id;\n                        })\n                    }\n                } else {\n                    // if no splitLocations are given then split it in the middle.\n                    this.splitBranch(node, node.length / 2.0);\n                }\n            });\n    }\n\n    /**\n     * Splits a branch in two inserting a new degree 2 node. The splitLocation should be less than\n     * the orginal branch length.\n     * @param node\n     * @param splitLocation\n     */\n    splitBranch(node, splitLocation) {\n        const oldLength = node.length;\n\n        let splitNode = {\n            parent: node.parent,\n            children: [node],\n            length: oldLength - splitLocation,\n            annotations: {\n                midpoint: true\n            }\n        };\n        node.parent.children[node.parent.children.indexOf(node)] = splitNode;\n        node.parent = splitNode;\n        node.length = splitLocation;\n\n        return splitNode;\n    }\n\n    /**\n     * Set one or more annotations for the tips.\n     *\n     * See annotateNode for a description of the annotation structure.\n     *\n     * @param annotations a dictionary of annotations keyed by tip label\n     */\n    annotateTips(annotations) {\n        for (let [key, values] of Object.entries(annotations)) {\n            const tip = this.getExternalNode(key);\n            if (!tip) {\n                throw new Error(`tip with label ${key} not found in tree`);\n            }\n            this.annotateNode(tip, values);\n        }\n    }\n\n    /**\n     * This is similar to annotateTips but the annotation objects are keyed by node\n     * keys (Symbols).\n     *\n     * @param annotations a dictionary of annotations keyed by node key\n     */\n    annotateNodes(annotations) {\n        for (let [key, values] of Object.entries(annotations)) {\n            const node = this.getNode(key);\n            if (!node) {\n                throw new Error(`tip with key ${key} not found in tree`);\n            }\n\n            this.annotateNode(node, values);\n        }\n    }\n\n    annotateNodesFromLabel(annotations){\n        for (let [key, values] of Object.entries(annotations)) {\n            const node = this.getNodeFromLabel(key);\n            if (!node) {\n                throw new Error(`tip with key ${key} not found in tree`);\n            }\n            this.annotateNode(node, values);\n        }\n    }\n\n        /**\n     * This is similar to annotateTips but the annotation objects are keyed by node\n     * keys (Symbols).\n     *\n     * @param annotations a dictionary of annotations keyed by node key\n     */\n    annotateNodesByLabel(annotations) {\n        for (let [key, values] of Object.entries(annotations)) {\n            const node = this.getNodeFromLabel(key);\n            if (!node) {\n                throw new Error(`tip with key ${key} not found in tree`);\n            }\n\n            this.annotateNode(node, values);\n        }\n    }\n\n    /**\n     * Adds the given annotations to a particular node object.\n     *\n     * The annotations is an object with properties keyed by external node labels each\n     * of which is an object with key value pairs for the annotations. The\n     * key value pairs will be added to a property called 'annotations' in the node.\n     *\n     * Boolean or Numerical traits are given as a single value.\n     * Sets of values with probabilities should be given as an object.\n     * Discrete values should be given as an array (even if containing only one value)\n     * or an object with booleans to give the full set of possible trait values.\n     *\n     * For example:\n     *\n     * {\n     *     'tip_1': {\n     *         'trait_1' : true,\n     *         'trait_4' : 3.141592,\n     *         'trait_2' : [1, 2], // discrete trait\n     *         'trait_3' : [\"London\", \"Paris\", \"New York\"], // discrete trait\n     *         'trait_3' : {\"London\" : true, \"Paris\" : false, \"New York\": false], // discrete trait with full set of values\n     *         'trait_4' : {\"London\" : 0.75, \"Paris\" : 0.20, \"New York\": 0.05} // probability set\n     *     },\n     *     'tip_2': {...}\n     * }\n     *\n     * The annotation labels, type and possible values are also added to the tree in a property called 'annotations'.\n     *\n     * A reconstruction method such as annotateNodesFromTips can then be used to provide reconstructed values\n     * for internal nodes. Or annotateNodes can provide annotations for any node in the tree.\n     *\n     * @param node\n     * @param annotations a dictionary of annotations keyed by the annotation name.\n     */\n    annotateNode(node, annotations) {\n        this.addAnnotations(annotations);\n\n        // add the annotations to the existing annotations object for the node object\n        node.annotations = {...(node.annotations === undefined ? {} : node.annotations), ...annotations};\n    }\n\n    /**\n     * Adds the annotation information to the tree. This stores the type and possible values\n     * for each annotation seen in the nodes of the tree.\n     *\n     * This methods also checks the values are correct and conform to previous annotations\n     * in type.\n     *\n     * @param annotations\n     */\n     /**\n    * This methods also checks the values are correct and conform to previous annotations\n    * in type.\n    *\n    * @param annotations\n    */\n   addAnnotations(datum) {\n    for (let [key, addValues] of Object.entries(datum)) {\n        if(addValues instanceof Date||  typeof addValues === 'symbol'){\n            continue; // don't handel dates yet\n        }\n         let annotation = this.annotations[key];\n        if (!annotation) {\n            annotation = {};\n            this.annotations[key] = annotation;\n        }\n\n        if(typeof addValues === 'string' || addValues instanceof String){\n            // fake it as an array\n            addValues = [addValues];\n        }\n        if (Array.isArray(addValues)) {\n            // is a set of discrete values or \n            const type = Type.DISCRETE;\n\n            if (annotation.type && annotation.type !== type) {\n                throw Error(`existing values of the annotation, ${key}, in the tree is not of the same type`);\n            }\n            annotation.type = type;\n            annotation.values = annotation.values? [...annotation.values, ...addValues]:[...addValues]\n        } else if (Object.isExtensible(addValues)) {\n            // is a set of properties with values               \n            let type = null;\n\n            let sum = 0.0;\n            let keys = [];\n            for (let [key, value] of Object.entries(addValues)) {\n                if (keys.includes(key)) {\n                    throw Error(`the states of annotation, ${key}, should be unique`);\n                }\n                if (typeof value === typeof 1.0) {\n                    // This is a vector of probabilities of different states\n                    type = (type === undefined) ? Type.PROBABILITIES : type;\n\n                    if (type === Type.DISCRETE) {\n                        throw Error(`the values of annotation, ${key}, should be all boolean or all floats`);\n                    }\n\n                    sum += value;\n                    if (sum > 1.01) {\n                        throw Error(`the values of annotation, ${key}, should be probabilities of states and add to 1.0`);\n                    }\n                } else if (typeof value === typeof true) {\n                    type = (type === undefined) ? Type.DISCRETE : type;\n\n                    if (type === Type.PROBABILITIES) {\n                        throw Error(`the values of annotation, ${key}, should be all boolean or all floats`);\n                    }\n                } else {\n                    throw Error(`the values of annotation, ${key}, should be all boolean or all floats`);\n                }\n                keys.push(key);\n            }\n\n            if (annotation.type && annotation.type !== type) {\n                throw Error(`existing values of the annotation, ${key}, in the tree is not of the same type`);\n            }\n\n            annotation.type = type;\n            annotation.values = annotation.values? [...annotation.values, addValues]:[addValues]\n        } else {\n            let type = Type.DISCRETE;\n\n        if (typeof addValues === typeof true) {\n                type = Type.BOOLEAN;\n            } else if (!isNaN(addValues)){\n                type = (addValues % 1 === 0 ? Type.INTEGER : Type.FLOAT);\n            }\n\n            if (annotation.type && annotation.type !== type) {\n                if ((type === Type.INTEGER && annotation.type === Type.FLOAT) ||\n                    (type === Type.FLOAT && annotation.type === Type.INTEGER)) {\n                    // upgrade to float\n                    type = Type.FLOAT;\n                } else {\n                    throw Error(`existing values of the annotation, ${key}, in the tree is not of the same type`);\n                }\n            }\n\n            if (type === Type.DISCRETE) {\n                if (!annotation.values) {\n                    annotation.values = new Set();\n                }\n                 annotation.values.add(addValues);\n             \n            }\n\n            annotation.type = type;\n        }\n\n        // overwrite the existing annotation property\n        this.annotations[key] = annotation;\n    }\n}\n\n    /**\n     * Uses parsimony to label internal nodes to reconstruct the internal node states\n     * for the annotation 'name'.\n     *\n     * @param name\n     * @param acctrans Use acctrans reconstruction if true, deltrans otherwise\n     * @param node\n     */\n    annotateNodesFromTips(name, acctran = true) {\n        fitchParsimony(name, this.rootNode);\n\n        reconstructInternalStates(name, [], acctran, this.rootNode);\n    }\n\n    /**\n     * A class method to create a Tree instance from a Newick format string (potentially with node\n     * labels and branch lengths). Taxon labels should be quoted (either \" or ') if they contain whitespace\n     * or any of the tree definitition characters '(),:;' - the quotes (and any whitespace immediately within)\n     * will be removed.\n     * @param newickString - the Newick format tree as a string\n     * @param labelName\n     * @param datePrefix\n     * @returns {Tree} - an instance of the Tree class\n     */\n    static parseNewick(newickString, labelName = \"label\", datePrefix = undefined ) {\n        const tokens = newickString.split(/\\s*('[^']+'|\"[^\"]+\"|;|\\(|\\)|,|:)\\s*/);\n\n        let level = 0;\n        let currentNode = null;\n        let nodeStack = [];\n        let labelNext = false;\n        let lengthNext = false;\n\n        for (const token of tokens.filter(token => token.length > 0)) {\n            // console.log(`Token ${i}: ${token}, level: ${level}`);\n            if (token === \"(\") {\n                // an internal node\n\n                if (labelNext) {\n                    // if labelNext is set then the last bracket has just closed\n                    // so there shouldn't be an open bracket.\n                    throw new Error(\"expecting a comma\");\n                }\n\n                let node = {\n                    level: level,\n                    parent: currentNode,\n                    children: [],\n                    annotations: {}\n                };\n                level += 1;\n                if (currentNode) {\n                    nodeStack.push(currentNode);\n                }\n                currentNode = node;\n\n            } else if (token === \",\") {\n                // another branch in an internal node\n\n                labelNext = false; // labels are optional\n                if (lengthNext) {\n                    throw new Error(\"branch length missing\");\n                }\n\n                let parent = nodeStack.pop();\n                parent.children.push(currentNode);\n\n                currentNode = parent;\n            } else if (token === \")\") {\n                // finished an internal node\n\n                labelNext = false; // labels are optional\n                if (lengthNext) {\n                    throw new Error(\"branch length missing\");\n                }\n\n                // the end of an internal node\n                let parent = nodeStack.pop();\n                parent.children.push(currentNode);\n\n                level -= 1;\n                currentNode = parent;\n\n                labelNext = true;\n            } else if (token === \":\") {\n                labelNext = false; // labels are optional\n                lengthNext = true;\n            } else if (token === \";\") {\n                // end of the tree, check that we are back at level 0\n                if (level > 0) {\n                    throw new Error(\"unexpected semi-colon in tree\")\n                }\n                break;\n            } else {\n                // not any specific token so may be a label, a length, or an external node name\n                if (lengthNext) {\n                    currentNode.length = parseFloat(token);\n                    lengthNext = false;\n                } else if (labelNext) {\n                    currentNode.label = token;\n                    if (!currentNode.label.startsWith(\"#\")) {\n                        let value = parseFloat(currentNode.label);\n                        if (isNaN(value)) {\n                            value = currentNode.label;\n                        }\n                        currentNode.annotations[labelName] = value;\n                    } else {\n                        currentNode.id = currentNode.label.substring(1);\n                    }\n                    labelNext = false;\n                } else {\n                    // an external node\n                    if (!currentNode.children) {\n                        currentNode.children = []\n                    }\n\n                    let name = token;\n\n                    // remove any quoting and then trim whitespace\n                    if (name.startsWith(\"\\\"\") || name.startsWith(\"'\")) {\n                        name = name.substr(1);\n                    }\n                    if (name.endsWith(\"\\\"\") || name.endsWith(\"'\")) {\n                        name = name.substr(0, name.length - 1);\n                    }\n                    name = name.trim();\n\n                    let date = undefined;\n                    if (datePrefix) {\n                        const parts = name.split(datePrefix);\n                        if (parts.length === 0) {\n                            throw new Error(`the tip, ${name}, doesn't have a date separated by the prefix, '${datePrefix}'`);\n                        }\n                        date = parseFloat(parts[parts.length - 1]);\n                    }\n\n                    const externalNode = {\n                        name: name,\n                        date: date,\n                        parent: currentNode,\n                        annotations: {}\n                    };\n\n                    if (currentNode) {\n                        nodeStack.push(currentNode);\n                    }\n                    currentNode = externalNode;\n                }\n            }\n        }\n\n        if (level > 0) {\n            throw new Error(\"the brackets in the newick file are not balanced\")\n        }\n\n        return new Tree(currentNode);\n    };\n}\n\n/*\n * Private methods, called by the class using the <function>.call(this) function.\n */\n\n/**\n * A private recursive function that rotates nodes to give an ordering.\n * @param node\n * @param increasing\n * @param callback an optional callback that is called each rotate\n * @returns {number}\n */\nfunction orderNodes(node, increasing, callback = null) {\n    const factor = increasing ? 1 : -1;\n    let count = 0;\n    if (node.children) {\n        const counts = new Map();\n        for (const child of node.children) {\n            const value = orderNodes(child, increasing, callback);\n            counts.set(child, value);\n            count += value;\n        }\n        node.children.sort((a, b) => {\n            return (counts.get(a) - counts.get(b)) * factor\n        });\n\n        if (callback) callback();\n    } else {\n        count = 1\n    }\n    return count;\n}\n\n/**\n * A private recursive function that uses the Fitch algorithm to assign\n * states to nodes using parsimony. An acctrans or deltrans algorithm can\n * then be used to reconstruct internal node states.\n * @param name\n * @param node\n * @returns {*}\n */\nfunction fitchParsimony(name, node) {\n\n    if (!node.children) {\n        if (!node.annotations[name]) {\n            return []; // annotation not defined so return an empty set\n        }\n        return (Array.isArray(node.annotations[name]) ? node.annotations[name] : [node.annotations[name]]);\n    }\n\n    let I;\n    let U = [];\n    node.children.forEach( (child) => {\n        const childStates = fitchParsimony(name, child);\n        U = [...U, ...childStates.filter( (state) => !U.includes(state) )]; // take the union\n        I = (I === undefined ? childStates : childStates.filter( (state) => I.includes(state) )); // take the intersection\n    });\n\n    node.annotations = (node.annotations === undefined ? {} : node.annotations);\n\n    // set the node annotation to the intersection if not empty, the union otherwise\n    node.annotations[name] = [...(I.length > 0 ? I : U)];\n\n    return node.annotations[name];\n}\n\nfunction reconstructInternalStates(name, parentStates, acctran, node ) {\n    let nodeStates = node.annotations[name];\n    if (!Array.isArray(nodeStates)) {\n        nodeStates = [nodeStates];\n    }\n\n    if (node.children) {\n\n        let stateCounts = {};\n\n        nodeStates\n            .forEach((state) => stateCounts[state] = (stateCounts[state] ? stateCounts[state] += 1 : 1) );\n\n        parentStates\n            .forEach((state) => stateCounts[state] = (stateCounts[state] ? stateCounts[state] += 1 : 1) );\n\n        node.children.forEach((child) => {\n            reconstructInternalStates(name, nodeStates, acctran, child)\n                .forEach((state) => stateCounts[state] = (stateCounts[state] ? stateCounts[state] += 1 : 1) );\n        });\n\n        const max = Object.entries(stateCounts).reduce((prev, current) => (prev[1] > current[1]) ? prev : current)[1];\n        nodeStates = Object.entries(stateCounts).filter(([state, count]) => count === max).map(([state, count]) => state );\n\n        node.annotations[name] = (nodeStates.length === 1 ? nodeStates[0] : nodeStates);\n    }\n\n    return nodeStates;\n}","import {select} from 'd3-selection';\nimport {scaleLinear} from 'd3-scale';\nimport {axisBottom,axisLeft} from 'd3-axis';\nimport {easeLinear} from 'd3-ease';\nimport {Type} from '../figtree.js/tree.js';\nimport {event} from 'd3';\n/**\n * A master class for each plot that requires each plot implement a draw\n * update, onclick and onhover method.\n */\n\nexport class  d3Plot{\n    static DEFAULT_SETTINGS() {\n        return {\n      tranitionDuration:0,\n      xScaleType:scaleLinear,\n      yScaleType:scaleLinear,\n      yAxisType:axisLeft,\n      xAxisType:axisBottom,\n        }\n      }\n      /**\n       * The constructor\n       * @param {*} svg \n       * @param {*} layout \n       * @param {*} margins top,bottom,left,right\n       * @param {*} settings \n       */\n    constructor(svg, layout, margins, settings = {}){\n      this.layout = layout;\n      this.margins = margins;\n\n      // merge the default settings with the supplied settings\n      this.settings = {...d3Plot.DEFAULT_SETTINGS(), ...settings};\n      this.svg=svg;\n      }\n      /**\n       * set up the svg get the size of the svg, translate it to the top\n       * left, remove all 'g' and add a g to hold the plot. make a this.svgSelection\n       * for easy access later.\n       */\n      draw(){\n            // get the size of the svg we are drawing on\n        let width,height;\n        if(Object.keys(this.settings).indexOf(\"width\")>-1){\n            width =this.settings.width;\n        }else{\n            width = this.svg.getBoundingClientRect().width;\n        }\n        if(Object.keys(this.settings).indexOf(\"height\")>-1){\n            height =this.settings.height;\n        }else{\n            height = this.svg.getBoundingClientRect().height;\n        }\n \n        //remove the tree if it is there already\n        select(this.svg).select(\"g\").remove();\n \n        // add a group which will contain the new plot\n        select(this.svg).append(\"g\")\n            .attr(\"transform\",`translate(${this.margins.left},${this.margins.top})`);\n \n         //to selecting every time\n         this.svgSelection = select(this.svg).select(\"g\");\n\n         this.svgSelection.append(\"g\").attr(\"class\", \"axes-layer\");\n\n         this.addDataLayers();\n         \n         // create the scales\n         const xScale = this.settings.xScaleType()\n         .domain(this.layout.horizontalRange)\n         .range([this.margins.left, width - this.margins.right-this.margins.left]);\n         \n         //height is total \n         const yScale = this.settings.yScaleType()\n             .domain(this.layout.verticalRange)\n             .range([height -this.margins.bottom-this.margins.top,this.margins.top]);\n \n         this.scales = {x:xScale, y:yScale, width, height};\n         this.addAxis();\n \n         // Called whenever the layout changes...\n           this.layout.updateCallback = () => {\n                 this.update();\n             }\n     \n             this.update();\n      }\n      // adds layers to hold data here. They are the layers referenced in the update call\n      addDataLayers(){\n      }\n      /**\n       * An update function to be overwritten by member classes. This takes the svg selection\n       * and goes through the join, enter, exit cycle.\n       */\n\n      update(){\n      }\n\n      /**\n     * Add a hover callback\n     * @param {*} action  - object which has 2 functions enter and exit each takes 3 arguments d,i,n d is data n[i] is `this`\n     * @param {*} selection  - what to select defaults to\n     */\n    onHover(action,selection=null){\n        const selected = this.svgSelection.selectAll(`${selection}`);\n        selected.on(\"mouseover\", (d,i,n) => {\n            action.enter(d,i,n);\n        });\n        selected.on(\"mouseout\", (d,i,n) => {\n            action.exit(d,i,n);\n        });\n    }\n    onClick(action,selection=null){\n    const selected = this.svgSelection.selectAll(`${selection}`);\n    selected.on(\"click\", (d,i,n) => {\n        action(d,i,n);\n    });\n    }\n\n     /**\n     * Registers some text to appear in a popup box when the mouse hovers over the selection.\n     *\n     * @param selection\n     * @param text\n     */\n    addToolTip(selection, renderText) {\n        this.svgSelection.selectAll(selection).on(\"mouseover\",\n            function (d,i,n) {\n                const tooltip = document.getElementById(\"tooltip\");\n                    tooltip.innerHTML = renderText(d,i,n);\n              \n                tooltip.style.display = \"block\";\n                tooltip.style.left =event.pageX + 10 + \"px\";\n                tooltip.style.top = event.pageY + 10 + \"px\";\n                tooltip.style.visibility =\"visible\";\n            }\n        );\n        this.svgSelection.selectAll(selection).on(\"mouseout\", function () {\n            const tooltip = document.getElementById(\"tooltip\");\n            tooltip.style.visibility = \"hidden\";\n        });\n    }\n\n    addAxis(){\n        const axesLayer = this.svgSelection.select(\".axes-layer\");  \n        if(this.settings.xAxisType){\n            axesLayer.append(\"g\")\n            .attr(\"class\", \"x axis\")\n            .attr(\"id\", \"x-axis\")\n            .attr(\"transform\", `translate(0, ${this.scales.height - this.margins.bottom + 5})`)\n            .call(axisBottom(this.scales.x).tickValues(this.layout.horizontalAxisTicks));\n        }\n        if(this.settings.yAxisType){\n            axesLayer.append(\"g\")\n            .attr(\"class\", \"y axis\")\n            .attr(\"id\", \"y-axis\")\n            .attr(\"transform\", `translate(${this.margins.left/2},0)`)\n            .call(axisLeft(this.scales.y).ticks(5));\n        }\n    }\n    updateAxis(){\n        this.svgSelection.select(\"#x-axis\")\n            .call(axisBottom(this.scales.x).tickValues(this.layout.horizontalAxisTicks))\n            .attr(\"transform\", `translate(0, ${this.scales.height - this.margins.bottom + 5})`)\n            .transition()\n            .duration(this.settings.transitionDuration)\n            .ease(easeLinear);\n\n        \n        this.svgSelection.select(\"#y-axis\")\n        .attr(\"transform\", `translate(${this.margins.left/2},0)`)\n        .call(axisLeft(this.scales.y).ticks(5))\n        .transition()\n        .duration(this.settings.transitionDuration)\n        .ease(easeLinear)\n    }\n\n    updateAxisBars(){\n        const axesLayer = this.svgSelection.select(\".axes-layer\");  \n        const ticks = []\n        for(let i=0;i<(this.layout.horizontalAxisTicks.length-1);i++){\n            ticks.push({x0:this.layout.horizontalAxisTicks[i],\n                        x1:this.layout.horizontalAxisTicks[i+1]})\n        }\n    // DATA JOIN\n    // Join new data with old elements, if any.\n        const axisBoxes = axesLayer.selectAll(\".axis-box\")\n            .data(ticks)\n    // ENTER\n    // Create new elements as needed.\n    const newBoxes = axisBoxes.enter()\n                    .append('rect')\n                    .attr(\"x\", d => this.scales.x(d.x0))\n                    .attr(\"width\", d =>this.scales.x(d.x1) - this.scales.x(d.x0))\n                    .attr(\"y\", d => 0)\n                    .attr(\"height\", d => this.scales.height-this.margins.bottom-this.margins.top)\n                    .attr(\"class\", (d,i) => i%2===0? `axis-box even`:`axis-box odd`);\n    \n        axisBoxes\n        .transition()\n        .duration(this.settings.transitionDuration)\n        .attr(\"x\", d => this.scales.x(d.x0))\n        .attr(\"width\", d => this.scales.x(d.x1) - this.scales.x(d.x0))\n        .attr(\"y\", d => 0)\n        .attr(\"height\", d => this.scales.height-this.margins.bottom-this.margins.top)\n        .attr(\"class\", (d,i) => i%2===0? `axis-box even`:`axis-box odd`);\n\n\n        axisBoxes.exit().remove();\n    }\n\n    getAnnotations(datum){\n       const annotationClasses=[ ...Object.entries(datum)\n                            .filter(([key]) => {\n                                if(!this.layout.annotations[key]){\n                                    return false;\n                                }\n                                return this.layout.annotations[key].type === Type.DISCRETE ||\n                                    this.layout.annotations[key].type === Type.BOOLEAN ||\n                                    this.layout.annotations[key].type === Type.INTEGER;\n                            })\n                            .map(([key, value]) => `${key}-${value}`)];\n        return annotationClasses\n    }\n    \n    \n}\n","import {axisLeft, axisBottom} from \"d3-axis\";\nimport {select,selectAll} from \"d3-selection\";\nimport {scaleLinear,scaleTime} from \"d3-scale\";\nimport {easeLinear} from \"d3-ease\";\nimport {d3Plot} from \"./d3Plot\";\n\nexport class stackedHistogramChart extends d3Plot{\n  static DEFAULT_SETTINGS() {\n        return {\n      hoverBorder: 2,\n      backgroundBorder: 0,\n      baubles: [],\n      transitionDuration:0,\n        }\n      }\n      /**\n       * The constructor\n       * @param {*} svg \n       * @param {*} layout \n       * @param {*} margins top,bottom,left,right\n       * @param {*} settings \n       */\n    constructor(svg, layout, margins, settings = {}){\n      super();\n      this.layout = layout;\n      this.margins = margins;\n\n      // merge the default settings with the supplied settings\n      this.settings = {...d3Plot.DEFAULT_SETTINGS(), ...stackedHistogramChart.DEFAULT_SETTINGS(), ...settings};\n      this.svg=svg;\n      }\n      /**\n       * @override\n       * Adds rect-background and rect layers for data addition later\n       */\n      addDataLayers(){\n          if (this.settings.backgroundBorder > 0) {\n              this.svgSelection.append(\"g\").attr(\"class\", \"rect-background-layer\");\n          }\n          this.svgSelection.append(\"g\").attr(\"class\", \"rect-layer\");\n      }\n        update(){\n        // get new positions\n        this.bins = []; // rest to so will be filled\n        this.layout.layout(this.bins);\n        // svg may have changed sizes\n        let width,height;\n        if(Object.keys(this.settings).indexOf(\"width\")>-1){\n            width =this.settings.width;\n        }else{\n            width = this.svg.getBoundingClientRect().width;\n        }\n        if(Object.keys(this.settings).indexOf(\"height\")>-1){\n            height =this.settings.height;\n        }else{\n            height = this.svg.getBoundingClientRect().height;\n        }\n        // update the scales' domains\n        this.scales.x.domain(this.layout.horizontalRange).range([this.margins.left, width - this.margins.right-this.margins.left]);\n        this.scales.y.domain(this.layout.verticalRange).range([height -this.margins.bottom-this.margins.top,this.margins.top]);\n        this.scales.width=width;\n        this.scales.height=height;\n\n\n        if (this.settings.backgroundBorder > 0) {\n          updateRectBackgrounds.call(this);\n      }\n\n      updateRects.call(this);\n      this.updateAxis();\n      // this.updateAxisBars();\n\n    }\n/**\n * Add a hover callback\n * @param {*} action  - object which has 2 functions enter and exit each takes 3 arguments d,i,n d is data n[i] is `this`\n * @param {*} selection  - what to select defaults to .rect class\n */\n  // onHover(action,selection=null){\n  //     const selected = this.svgSelection.selectAll(`${selection ? selection : \".rect\"}`);\n  //     selected.on(\"mouseover\", (d,i,n) => {\n  //         action.enter(d,i,n);\n  //     });\n  //     selected.on(\"mouseout\", (d,i,n) => {\n  //         action.exit(d,i,n);\n  //     });\n  // }\n  // onClick(action,selection=null){\n  //   const selected = this.svgSelection.selectAll(`${selection ? selection : \".rect\"}`);\n  //   selected.on(\"click\", (d,i,n) => {\n  //       action(d,i,n);\n  //   });\n  // }\n\n  }\n    /**\n     * adds or updates rects\n     */\nfunction updateRects(){\n      const rectLayer = select(this.svg).select(\".rect-layer\");\n\n    // DATA JOIN\n    // Join new data with old elements, if any.\n      const rects = rectLayer.selectAll(\".rect\")\n                  .data(this.bins, (c) => `c_${c.data.id}`);\n    // ENTER\n    // Create new elements as needed.\n    const newRects = rects.enter()\n      .append(\"rect\")\n      .attr(\"id\", (v) => v.id)\n      .attr(\"class\", (v) => [\"rect\",...this.getAnnotations(v.data)].join(\" \")) // add attribute classes here\n      .attr(\"x\", d => this.scales.x(d.x0) + 1)\n      .attr(\"width\", d => Math.max(0, this.scales.x(d.x1) - this.scales.x(d.x0) - 1))\n      .attr(\"y\", d => this.scales.y(d.y1))\n      .attr(\"height\", d => this.scales.y(d.y0)- this.scales.y(d.y1));\n\n       // update the existing elements\n       rects\n        .transition()\n        .duration(this.settings.transitionDuration)\n        .attr(\"x\", d => this.scales.x(d.x0) + 1)\n        .attr(\"width\", d => Math.max(0, this.scales.x(d.x1) - this.scales.x(d.x0) - 1))\n        .attr(\"y\", d => this.scales.y(d.y1))\n        .attr(\"height\", d => this.scales.y(d.y0)- this.scales.y(d.y1));\n\n     // EXIT\n    // Remove old elements as needed.\n    rects.exit().remove();\n    }\nfunction updateRectBackgrounds(){\n  const rectBackgroundLayer = this.svgSelection.select(\".rect-background-layer\");\n      // DATA JOIN\n    // Join new data with old elements, if any.\n    const rects = rectBackgroundLayer.selectAll(\".rect-background\")\n    .data(this.bins, (c) => `cb_${c.data.id}`);\n    // ENTER\n    // Create new elements as needed.\n    const newRects = rects.enter()\n    .append(\"rect\")\n    .attr(\"id\", (v) => v.id)\n    .attr(\"class\", (v) => [\"rect-background\",...this.getAnnotations(v.data)].join(\" \")) // add attribute classes \n    .attr(\"x\", d => this.scales.x(d.x0) + 1)\n    .attr(\"width\", d => Math.max(0, this.scales.x(d.x1) - this.scales.x(d.x0) - 1))\n    .attr(\"y\", d => this.scales.y(d.y1))\n    .attr(\"height\", d => this.scales.y(d.y0)- this.scales.y(d.y1));\n\n    // update the existing elements\n    rects\n    .transition()\n    .duration(this.settings.transitionDuration)\n    .attr(\"x\", d => this.scales.x(d.x0) + 1)\n    .attr(\"width\", d => Math.max(0, this.scales.x(d.x1) - this.scales.x(d.x0) - 1))\n    .attr(\"y\", d => this.scales.y(d.y1))\n    .attr(\"height\", d => this.scales.y(d.y0)- this.scales.y(d.y1));\n\n    // EXIT\n    // Remove old elements as needed.\n    rects.exit().remove();\n\n}\n\n","\"use strict\";\n\n/** @module layout */\n\n\n/**\n * The Layout class\n *\n */\nexport class Layout {\n\n    /**\n     * The constructor.\n     */\n    constructor( ) {\n\n        // default ranges - these should be set in layout()\n        this._horizontalRange = [0.0, 1.0];\n        this._verticalRange = [0, 1.0];\n        this._horizontalTicks= [0,0.5,1]\n\n        // create an empty callback function\n        this.updateCallback = () => { };\n    }\n\n    /**\n     * An abstract base class for a layout class. The aim is to describe the API of the class.\n     *\n     * @param vertices - objects with an x, y coordinates and a reference to the original node\n     * @param edges - objects with v1 (a vertex) and v0 (the parent vertex).\n     */\n    layout(vertices, edges) { }\n\n    get horizontalRange() {\n        return this._horizontalRange;\n    }\n\n    get verticalRange() {\n        return this._verticalRange;\n    }\n    get horizontalAxisTicks(){\n        return this._horizontalTicks;\n    }\n    /**\n     * Updates the tree when it has changed\n     */\n    update() {\n        this.updateCallback();\n    }\n\n    /**\n     * A utility function for rotating a node\n     * @returns {rotate}\n     */\n    rotate() {\n        return (vertex) => {\n            this.tree.rotate(vertex.node);\n            this.update();\n        };\n    }\n\n    /**\n     * A utility function for ordering a subtree with increasing tip density\n     * @returns {orderIncreasing}\n     */\n    orderIncreasing() {\n        return (vertex) => {\n            this.tree.rotate(vertex.node);\n            this.update();\n        };\n    }\n\n    /**\n     * A utility function for ordering a subtree with decreasing tip density\n     * @returns {orderIncreasing}\n     */\n    orderDecreasing() {\n        return (vertex) => {\n            this.tree.rotate(vertex.node);\n            this.update();\n        };\n    }\n\n    /**\n     * A utility function for rerooting the tree\n     * @returns {reroot}\n     */\n    reroot() {\n        return (edge, position) => {\n            this.tree.reroot(edge.v1.node, position);\n            this.update();\n        };\n    }\n\n    /**\n     * A utility function that will return a HTML string about the node and its\n     * annotations. Can be used with the addLabels() method.\n     *\n     * @param node\n     * @returns {string}\n     */\n    static nodeInfo(node) {\n        let text = `${node.name ? node.name : node.id }`;\n        Object.entries(node.annotations).forEach(([key, value]) => {\n            text += `<p>${key}: ${value}</p>`;\n        });\n        return text;\n    }\n}\n\n/*\n * Private methods, called by the class using the <function>.call(this) function.\n */\n\n","\"use strict\";\n\n/** @module layout */\n\nimport { Layout } from \"./layout.js\";\nimport { Type } from \"./tree.js\";\nimport {format,curveStepBefore,max,line,mean,scaleLinear} from \"d3\";\n\n// const d3 = require(\"d3\");\n/**\n * The Layout class\n *\n */\nexport class RectangularLayout extends Layout {\n\n    static DEFAULT_SETTINGS() {\n        return {\n            lengthFormat: format(\".2f\"),\n            branchCurve: curveStepBefore,\n            horizontalScale: null, // a scale that converts root to tip distance to 0,1 domain. default is 0 = root 1 = highest tip\n        };\n    }\n\n    /**\n     * The constructor.\n     * @param tree\n     * @param settings\n     */\n    constructor(tree, settings = { }) {\n        super();\n\n        this.tree = tree;\n\n        // merge the default settings with the supplied settings\n        this.settings = {...RectangularLayout.DEFAULT_SETTINGS(), ...settings};\n\n        this.branchLabelAnnotationName = null;\n        this.internalNodeLabelAnnotationName = null;\n        this.externalNodeLabelAnnotationName = null;\n\n        // called whenever the tree changes...\n        this.tree.treeUpdateCallback = () => {\n            this.update();\n        };\n    }\n\n    /**\n     * Lays out the tree in a standard rectangular format.\n     *\n     * This function is called by the FigTree class and is used to layout the nodes of the tree. It\n     * populates the vertices array with vertex objects that wrap the nodes and have coordinates and\n     * populates the edges array with edge objects that have two vertices.\n     *\n     * It encapsulates the tree object to keep it abstract\n     *\n     * @param vertices - objects with an x, y coordinates and a reference to the original node\n     * @param edges - objects with v1 (a vertex) and v0 (the parent vertex).\n     */\n    layout(vertices, edges) {\n\n        this._horizontalRange = [0,1];//[0.0, max([...this.tree.rootToTipLengths()])];\n        this._verticalRange = [0, this.tree.externalNodes.length - 1];\n         if(!this.settings.horizontalScale){\n             this.horizontalScale = scaleLinear().domain([0,max([...this.tree.rootToTipLengths()])]).range(this._horizontalRange);\n         }else{\n             this.horizontalScale = this.settings.horizontalScale;\n         }\n\n        // get the nodes in post-order\n        const nodes = [...this.tree.postorder()];\n\n        let currentY = -1;\n\n        if (vertices.length === 0) {\n            this.nodeMap = new Map();\n\n            // create the vertices (only done if the array is empty)\n            nodes.forEach((n, i) => {\n                const vertex = {\n                    node: n,\n                    key: n.id\n                    // key: Symbol(n.id).toString()\n                };\n                vertices.push(vertex);\n                this.nodeMap.set(n, vertex);\n            });\n        }\n\n        // update the node locations (vertices)\n        nodes\n            .forEach((n) => {\n                const v = this.nodeMap.get(n);\n\n                v.x = this.horizontalScale(this.tree.rootToTipLength(v.node));\n                currentY = this.setYPosition(v, currentY)\n\n                v.degree = (v.node.children ? v.node.children.length + 1: 1); // the number of edges (including stem)\n\n                v.id = n.id;\n\n                v.classes = [\n                    (!v.node.children ? \"external-node\" : \"internal-node\"),\n                    (v.node.isSelected ? \"selected\" : \"unselected\")];\n\n                if (v.node.annotations) {\n                    v.classes = [\n                        ...v.classes,\n                        ...Object.entries(v.node.annotations)\n                            .filter(([key]) => {\n                                return this.tree.annotations[key] &&\n                                    (this.tree.annotations[key].type === Type.DISCRETE ||\n                                    this.tree.annotations[key].type === Type.BOOLEAN ||\n                                    this.tree.annotations[key].type === Type.INTEGER);\n                            })\n                            .map(([key, value]) => `${key}-${value}`)];\n                }\n\n                // either the tip name or the internal node label\n                if (v.node.children) {\n                    v.leftLabel = (this.internalNodeLabelAnnotationName?\n                        v.node.annotations[this.internalNodeLabelAnnotationName]:\n                        \"\");\n                    v.rightLabel = \"\";\n\n                    // should the left node label be above or below the node?\n                    v.labelBelow = (!v.node.parent || v.node.parent.children[0] !== v.node);\n                } else {\n                    v.leftLabel = \"\";\n                    v.rightLabel = (this.externalNodeLabelAnnotationName?\n                        v.node.annotations[this.externalNodeLabelAnnotationName]:\n                        v.node.name);\n                }\n\n                this.nodeMap.set(v.node, v);\n            });\n\n        if (edges.length === 0) {\n            this.edgeMap = new Map();\n\n            // create the edges (only done if the array is empty)\n            nodes\n                .filter((n) => n.parent) // exclude the root\n                .forEach((n, i) => {\n                    const edge = {\n                        v0: this.nodeMap.get(n.parent),\n                        v1: this.nodeMap.get(n),\n                        key: n.id\n                        // key: Symbol(n.id).toString()\n                    };\n                    edges.push(edge);\n                    this.edgeMap.set(edge, edge.v1);\n                });\n        }\n\n        // update the edges\n        edges\n            .forEach((e) => {\n                e.v1 = this.edgeMap.get(e);\n                e.v0 = this.nodeMap.get(e.v1.node.parent);\n                e.classes = [];\n                const termini = [];\n                traverseToEnd(e.v1.node,termini);\n\n                if (e.v1.node.annotations) {\n                    e.classes = [\n                        ...e.classes,\n                        ...termini.map(t=>`tip-${t}`),\n                        ...Object.entries(e.v1.node.annotations)\n                            .filter(([key]) => {\n                                return this.tree.annotations[key] &&\n                                    (this.tree.annotations[key].type === Type.DISCRETE ||\n                                    this.tree.annotations[key].type === Type.BOOLEAN ||\n                                    this.tree.annotations[key].type === Type.INTEGER);\n                            })\n                            .map(([key, value]) => `${key}-${value}`)];\n                }\n                const length = e.v1.x - e.v0.x;\n                e.length = length;\n                e.label = (this.branchLabelAnnotationName ?\n                    (this.branchLabelAnnotationName === 'length' ?\n                        this.settings.lengthFormat(length) :\n                        e.v1.node.annotations[this.branchLabelAnnotationName]) :\n                    null );\n                e.labelBelow = e.v1.node.parent.children[0] !== e.v1.node;\n            });\n    }\n\n    set branchCurve(curve) {\n        this.settings.branchCurve = curve;\n        this.update();\n    }\n\n\n    get branchCurve() {\n        return this.settings.branchCurve;\n    }\n\n    /**\n     * Sets the annotation to use as the node labels.\n     *\n     * @param annotationName\n     */\n    setInternalNodeLabels(annotationName) {\n        this.internalNodeLabelAnnotationName = annotationName;\n        this.update();\n    }\n\n\n    /**\n     * Sets the annotation to use as the node labels.\n     *\n     * @param annotationName\n     */\n    setExternalNodeLabels(annotationName) {\n        this.externalNodeLabelAnnotationName = annotationName;\n        this.update();\n    }\n\n    /**\n     * Sets the annotation to use as the node labels.\n     *\n     * @param annotationName\n     */\n    setBranchLabels(annotationName) {\n        this.branchLabelAnnotationName = annotationName;\n        this.update();\n    }\n\n\n    /**\n     * Updates the tree when it has changed\n     */\n    update() {\n        this.updateCallback();\n    }\n\n    setYPosition(vertex, currentY) {\n        vertex.y = (vertex.node.children ? mean(vertex.node.children, (child) => this.nodeMap.get(child).y) : currentY += 1);\n        return currentY;\n    }\n    branchPathGenerator(scales){\n        const branchPath =(e,i)=>{\n            const branchLine = line()\n                 .x((v) => v.x)\n                .y((v) => v.y)\n                .curve(this.branchCurve);\n            return(\n                branchLine(\n                    [{x: 0, y: scales.y(e.v0.y) - scales.y(e.v1.y)},\n                    {x: scales.x(e.v1.x) - scales.x(e.v0.x), y: 0}]\n                )\n            )\n            \n        }\n        return branchPath;\n    }\n}\n\n/*\n * Private methods, called by the class using the <function>.call(this) function.\n */\nfunction traverseToEnd(node,tips){\n    \n    if(node.children){\n        for(const child of node.children){\n            traverseToEnd(child,tips);\n        }\n        }\n        else{\n            tips.push(node.name)\n    }\n}\n\n","\"use strict\";\n\n/** @module layout */\n\nimport { RectangularLayout } from \"./rectangularLayout.js\";\n\nexport const Direction = {\n    UP : Symbol(\"UP\"),\n    DOWN : Symbol(\"DOWN\")\n};\n\n/**\n * The TransmissionLayout class\n *\n */\nexport class TransmissionLayout extends RectangularLayout {\n\n    /**\n     * The constructor.\n     * @param tree\n     * @param settings\n     */\n    constructor(tree, settings = { }) {\n        super(tree, settings);\n\n        this._direction = Direction.DOWN;\n    }\n\n    /**\n     * Set the direction to draw transmission (up or down).\n     * @param direction\n     */\n    set direction(direction) {\n        this._direction = direction;\n        this.update();\n    }\n\n    /**\n     * Inherited method overwritten to set the y-position of an internal node to the same as its\n     * first child which gives a visual directionality to the tree.\n     * @param vertex\n     * @param currentY\n     * @returns {*}\n     */\n    setYPosition(vertex, currentY) {\n        if (this._direction === Direction.UP) {\n            throw new Error(\"Up direction drawing not implemented yet\");\n        }\n\n        vertex.y = (vertex.node.children ? this.nodeMap.get(vertex.node.children[0]).y : currentY += 1);\n        return currentY;\n    }\n\n}\n/*\n * Private methods, called by the class using the <function>.call(this) function.\n */\n\n","\"use strict\";\n\n/** @module layout */\n\nimport { Layout } from \"./layout.js\";\nimport { Type } from \"./tree.js\";\n// const d3 = require(\"d3\");\nimport {format,curveLinear,line,range} from \"d3\";\n/**\n * The ArcLayout class\n * note the function in the settings that placed the nodes on the xaxis a 0,1 range. The horizontal range is always 0->1. it is this funciton's job\n * To map the nodes to that space. the default is the \n * node's index in the node list.\n */\nexport class ArcLayout extends Layout {\n\n    static DEFAULT_SETTINGS() {\n        return {\n            lengthFormat: format(\".2f\"),\n            edgeWidth:2,\n            xFunction:(n,i,t)=>i/t.length,\n            branchCurve:curveLinear,\n            curve:'arc',\n            opacity:d=>1\n            \n        };\n    }\n\n    /**\n     * The constructor.\n     * @param graph\n     * @param settings\n     */\n    constructor(graph, settings = { }) {\n        super();\n\n        this.graph = graph;\n        this.annotations={};\n        // merge the default settings with the supplied settings\n        this.settings = {...ArcLayout.DEFAULT_SETTINGS(), ...settings};\n\n        this.branchLabelAnnotationName = null;\n        this.internalNodeLabelAnnotationName = null;\n        this.externalNodeLabelAnnotationName = null;\n\n        // called whenever the tree changes...\n        // this.tree.treeUpdateCallback = () => {\n        //     this.update();\n        // };\n    }\n\n    /**\n     * Lays out the tree in a standard rectangular format.\n     *\n     * This function is called by the FigTree class and is used to layout the nodes of the tree. It\n     * populates the vertices array with vertex objects that wrap the nodes and have coordinates and\n     * populates the edges array with edge objects that have two vertices.\n     *\n     * It encapsulates the tree object to keep it abstract\n     *\n     * @param vertices - objects with an x, y coordinates and a reference to the original node\n     * @param edges - objects with v1 (a vertex) and v0 (the parent vertex).\n     */\n    layout(vertices, edges) {\n        this._horizontalRange = [0,1];\n        this._verticalRange = [-this.graph.nodes.length,this.graph.nodes.length];\n\n        // get the nodes in pre-order (starting at first node)\n        // const nodes = [...this.graph.preorder(this.graph.nodes[0])];\n        const nodes = [...this.graph.nodes];\n        nodes.forEach(n=>this.addAnnotations(n));\n\n\n        if (vertices.length === 0) {\n            this.nodeMap = new Map();\n\n            // create the vertices (only done if the array is empty)\n            nodes.forEach((n, i) => {\n                const vertex = {\n                    node: n,\n                    key: n.id\n                    // key: Symbol(n.id).toString()\n                };\n                vertices.push(vertex);\n                this.nodeMap.set(n, vertex);\n            });\n        }\n\n        const locations = nodes.reduce((acc,curr)=>{\n                                                    if(acc.indexOf(curr.location)===-1){\n                                                        acc.push(curr.location)\n                                                    }\n                                                    return(acc)\n                                                    },[])\n        const locationSpacing = 10;         \n\n        // update the node locations (vertices)\n        //\n        nodes\n            .forEach((n,i) => {\n                const v = this.nodeMap.get(n);\n                \n                v.x = this.settings.xFunction(n,i);\n                v.y = locations.indexOf(v.node.location) * locationSpacing - (locations.length * locationSpacing / 2);\n\n                v.degree = this.graph.getEdges(v.node).length ; // the number of edges\n                // console.log(v.x)\n                v.classes = [\n                    (!this.graph.getOutgoingEdges(v.node).length>0? \"external-node\" : \"internal-node\"),\n                    (v.node.isSelected ? \"selected\" : \"unselected\")];\n\n                // if (v.node.annotations) {\n                    v.classes = [\n                        ...v.classes,\n                        ...this.getAnnotations(v.node)]\n                // }\n\n                this.nodeMap.set(v.node, v);\n            });\n\n        if (edges.length === 0) {\n            this.edgeMap = new Map();\n\n            // create the edges (only done if the array is empty)\n            const dataEdges = this.graph.edges;\n            dataEdges.forEach(e=>{ this.addAnnotations(e.metaData);this.addAnnotations({source:e.source.id,target:e.target.id})})\n            dataEdges\n                .forEach((e, i) => {\n                    const edge = {\n                        // The source and targets here are nodes in the graph;\n                        v0: this.nodeMap.get(e.source),\n                        v1: this.nodeMap.get(e.target),\n                        key: e.id,\n                        data:e,\n                    };\n                    edges.push(edge);\n                    this.edgeMap.set(edge, edge.v1);\n                });\n        }\n\n        // update the edges\n\n\n        edges\n            .forEach((e) => {\n                e.v1 = this.edgeMap.get(e);\n                e.v0 = this.nodeMap.get(e.v0.node);\n                e.classes = [];\n\n\n                // if (e.v1.node.annotations) {\n                    let {id,...noId} = e.v1.node;\n                    e.classes = [\n                        ...e.classes,\n                        ...this.getAnnotations(noId), // no id in this \n                        ...this.getAnnotations(e.data.metaData),\n                        ...this.getAnnotations({source:e.data.source.id,target:e.data.target.id})\n                    ]\n\n\n                // }\n                const length = e.v1.x - e.v0.x;\n                e.length = length;\n                e.label = (this.branchLabelAnnotationName ?\n                    (this.branchLabelAnnotationName === 'length' ?\n                        this.settings.lengthFormat(length) :\n                        e.v1.node.annotations[this.branchLabelAnnotationName]) :\n                    null );\n                // e.labelBelow = e.v1.node.parent.children[0] !== e.v1.node;\n            });\n    }\n\n    set branchCurve(curve) {\n        this.settings.branchCurve = curve;\n        this.update();\n    }\n\n\n    get branchCurve() {\n        return this.settings.branchCurve;\n    }\n\n    /**\n     * Sets the annotation to use as the node labels.\n     *\n     * @param annotationName\n     */\n    setInternalNodeLabels(annotationName) {\n        this.internalNodeLabelAnnotationName = annotationName;\n        this.update();\n    }\n\n    /**\n     * Sets the annotation to use as the node labels.\n     *\n     * @param annotationName\n     */\n    setExternalNodeLabels(annotationName) {\n        this.externalNodeLabelAnnotationName = annotationName;\n        this.update();\n    }\n\n    /**\n     * Sets the annotation to use as the node labels.\n     *\n     * @param annotationName\n     */\n    setBranchLabels(annotationName) {\n        this.branchLabelAnnotationName = annotationName;\n        this.update();\n    }\n\n\n    /**\n     * Updates the tree when it has changed\n     */\n    update() {\n        this.updateCallback();\n    }\n\n    /* This methods also checks the values are correct and conform to previous annotations\n    * in type.\n    *\n    * @param annotations\n    */\n   addAnnotations(datum) {\n       for (let [key, addValues] of Object.entries(datum)) {\n           if(addValues instanceof Date||  typeof addValues === 'symbol'||addValues===null){\n               continue; // don't handel dates yet\n           }\n            let annotation = this.annotations[key];\n           if (!annotation) {\n               annotation = {};\n               this.annotations[key] = annotation;\n           }\n\n           if(typeof addValues === 'string' || addValues instanceof String){\n               // fake it as an array\n               addValues = [addValues];\n           }\n           if (Array.isArray(addValues)) {\n               // is a set of discrete values or \n               const type = Type.DISCRETE;\n\n               if (annotation.type && annotation.type !== type) {\n                   throw Error(`existing values of the annotation, ${key}, in the tree is not of the same type`);\n               }\n               annotation.type = type;\n               annotation.values = annotation.values? [...annotation.values, ...addValues]:[...addValues]\n           } else if (Object.isExtensible(addValues)) {\n               // is a set of properties with values               \n               let type = null;\n\n               let sum = 0.0;\n               let keys = [];\n               for (let [key, value] of Object.entries(addValues)) {\n                   if (keys.includes(key)) {\n                       throw Error(`the states of annotation, ${key}, should be unique`);\n                   }\n                   if (typeof value === typeof 1.0) {\n                       // This is a vector of probabilities of different states\n                       type = (type === undefined) ? Type.PROBABILITIES : type;\n\n                       if (type === Type.DISCRETE) {\n                           throw Error(`the values of annotation, ${key}, should be all boolean or all floats`);\n                       }\n\n                       sum += value;\n                       if (sum > 1.0) {\n                           throw Error(`the values of annotation, ${key}, should be probabilities of states and add to 1.0`);\n                       }\n                   } else if (typeof value === typeof true) {\n                       type = (type === undefined) ? Type.DISCRETE : type;\n\n                       if (type === Type.PROBABILITIES) {\n                           throw Error(`the values of annotation, ${key}, should be all boolean or all floats`);\n                       }\n                   } else {\n                       throw Error(`the values of annotation, ${key}, should be all boolean or all floats`);\n                   }\n                   keys.append(key);\n               }\n\n               if (annotation.type && annotation.type !== type) {\n                   throw Error(`existing values of the annotation, ${key}, in the tree is not of the same type`);\n               }\n\n               annotation.type = type;\n               annotation.values = annotation.values? [...annotation.values, ...addValues]:[...addValues]\n           } else {\n               let type = Type.DISCRETE;\n\n               if (typeof addValues === typeof true) {\n                   type = Type.BOOLEAN;\n               } else if (Number(addValues)) {\n                   type = (addValues % 1 === 0 ? Type.INTEGER : Type.FLOAT);\n               }\n\n               if (annotation.type && annotation.type !== type) {\n                   if ((type === Type.INTEGER && annotation.type === Type.FLOAT) ||\n                       (type === Type.FLOAT && annotation.type === Type.INTEGER)) {\n                       // upgrade to float\n                       type = Type.FLOAT;\n                   } else {\n                       throw Error(`existing values of the annotation, ${key}, in the tree is not of the same type`);\n                   }\n               }\n\n               if (type === Type.DISCRETE) {\n                   if (!annotation.values) {\n                       annotation.values = new Set();\n                   }\n                    annotation.values.add(addValues);\n                \n               }\n\n               annotation.type = type;\n           }\n\n           // overwrite the existing annotation property\n           this.annotations[key] = annotation;\n       }\n   }\n\n   getAnnotations(datum){\n    const annotationClasses=[ ...Object.entries(datum)\n                         .filter(([key]) => {\n                             if(!this.annotations[key]){\n                                 return false;\n                             }\n                             return this.annotations[key].type === Type.DISCRETE ||\n                                 this.annotations[key].type === Type.BOOLEAN ||\n                                 this.annotations[key].type === Type.INTEGER;\n                         })\n                         .map(([key, value]) => `${key}-${value}`)];\n     return annotationClasses\n }\n// Takes in scales and returns a function that will draw the branch paths given each edge and index as input.\n// branches have been translated so 0,0 is the top left hand corner of the group - \n    branchPathGenerator(scales){\n            const branchPath =(e,i)=>{\n                let points;\n            if(this.settings.curve===\"bezier\"){\n                const sign = i%2===0?1:-1;\n                \n                const startingP = {x:0,\n                                    y: scales.y(e.v0.y)-scales.y(e.v1.y)}; // which is 0 in the defualt setting\n                const endingP = {x:scales.x(e.v1.x)-scales.x(e.v0.x),\n                                y: 0};\n                const correctingFactor =  Math.abs(startingP.x-endingP.x)/(scales.x.range()[1]-scales.x.range()[0]); // so the longer the arc the heigher it goes\n                const controlPoint = {\"x\":startingP.x,\n                                        \"y\":sign*scales.y(scales.y.domain()[1])*correctingFactor};\n                const controlPoint1 = {\"x\":startingP.x,//+endingP.x)/3,\n                                        \"y\":sign*scales.y(scales.y.domain()[1])*correctingFactor};\n                    \n                const controlPoint2 = {\"x\":endingP.x,//+endingP.x)/3,\n                                        \"y\":sign*scales.y(scales.y.domain()[1])*correctingFactor};\n                points = cubicBezier(startingP,controlPoint1,controlPoint2,endingP)\n                // points = quadraticBezier(startingP,controlPoint,endingP)\n            }else{\n                const r = (scales.x(e.v1.x) - scales.x(e.v0.x))/2\n                const a = r; // center x position\n                const sign = i%2===0?1:-1;\n                const x = range(0,scales.x(e.v1.x) - scales.x(e.v0.x),1)//step every pixel\n                const y = x.map(x=>circleY(x,r,a,sign));\n                points = x.map((x,i)=>{\n                    return{x:x,y:y[i]}\n                }) \n            }\n\n                const branchLine = line()\n                     .x((v) => v.x)\n                    .y((v) => v.y)\n                    .curve(this.branchCurve);\n      \n            return(\n                branchLine(\n                    points\n                )\n            )\n            \n        }\n        return branchPath;\n    }\n\n}\n\n\n/*\n * Private methods, called by the class using the <function>.call(this) function.\n */\nfunction circleY(x,r,a,sign){\n        return  sign*(Math.sqrt(Math.pow(r,2)-Math.pow((x-a),2)))\n}\n\n/** Draws a quadraic bezier curve between two points\n * \n * @param {*} p0 - starting point {x:,y:}\n * @param {*} p1 - control point {x:,y:}\n * @param {*} p2- ending point {x:,y:}\n */\nfunction quadraticBezier(p0,p1,p2){\n    const points = [];\n    for(let t =0; t<=1;t+=0.01){\n        const x = Math.pow((1-t),2)*p0.x+2*(1-t)*t*p1.x+Math.pow(t,2)*p2.x;\n        const y = Math.pow((1-t),2)*p0.y+2*(1-t)*t*p1.y+Math.pow(t,2)*p2.y;\n        points.push({\"x\":x,\"y\":y});\n    }\n    return points;\n}\n/**\n * Cubic Bezier curves\n * @param {*} p0 -starting point\n * @param {*} p1 - ending point\n * @param {*} q0 control points\n * @param {*} q1 - control point 2\n */\nfunction cubicBezier(p0,p1,p2,p3){\n\n    const points = [];\n    for(let t =0; t<=1;t+=0.01){\n        const x = Math.pow((1-t),3)*p0.x + 3*Math.pow((1-t),2)*t*p1.x +  3*(1-t)*Math.pow(t,2)*p2.x + Math.pow(t,3)*p3.x;\n        const y = Math.pow((1-t),3)*p0.y + 3*Math.pow((1-t),2)*t*p1.y +  3*(1-t)*Math.pow(t,2)*p2.y + Math.pow(t,3)*p3.y;\n        points.push({\"x\":x,\"y\":y});\n    }\n    return points;\n}\n\n","\"use strict\";\n\n/** @module bauble */\n\n\n/**\n * The Bauble class\n *\n * This is a shape or decoration at the node of a tree or graph\n */\nexport class Bauble {\n    static DEFAULT_SETTINGS() {\n        return {\n            vertexFilter: () => true\n        };\n    }\n\n    /**\n     * The constructor.\n     */\n    constructor(settings = {}) {\n        this.settings = {...Bauble.DEFAULT_SETTINGS(), ...settings};\n    }\n\n    get vertexFilter() {\n        return this.settings.vertexFilter;\n    }\n\n    createShapes(selection) {\n        throw new Error(\"don't call the base class methods\")\n    }\n\n    updateShapes(selection, border = 0) {\n        throw new Error(\"don't call the base class methods\")\n    }\n\n}\n\nexport class CircleBauble extends Bauble {\n    static DEFAULT_SETTINGS() {\n        return {\n            radius: 6,\n        };\n    }\n\n    /**\n     * The constructor.\n     */\n    constructor(settings = {}) {\n        super({...CircleBauble.DEFAULT_SETTINGS(), ...settings});\n    }\n\n    createShapes(selection) {\n        return selection\n            .append(\"circle\");\n    };\n\n    updateShapes(selection, border = 0) {\n        return selection\n            .attr(\"cx\", 0)\n            .attr(\"cy\", 0)\n            .attr(\"r\", this.settings.radius + border);\n    };\n}\n\nexport class RectangularBauble extends Bauble {\n    static DEFAULT_SETTINGS() {\n        return {\n            height: 16,\n            width: 6,\n            radius: 2,\n        };\n    }\n\n    /**\n     * The constructor.\n     */\n    constructor(settings = {}) {\n        super({...RectangularBauble.DEFAULT_SETTINGS(), ...settings});\n    }\n\n    createShapes(selection) {\n        return selection\n            .append(\"rect\");\n    };\n\n    updateShapes(selection, border = 0) {\n        const w = this.settings.width + border;\n        const h = this.settings.height + border;\n        return selection\n            .attr(\"x\", - w / 2)\n                .attr(\"width\", w)\n                .attr(\"y\", - h / 2)\n                .attr(\"height\", h)\n                .attr(\"rx\", this.settings.radius)\n                .attr(\"ry\", this.settings.radius);\n    };\n}\n\n\n/*\n * Private methods, called by the class using the <function>.call(this) function.\n */\n\n","\"use strict\";\nimport {select,selectAll,scaleLinear,axisBottom,mouse,event} from \"d3\";\nimport {d3Plot} from \"../charts/d3Plot\";\n/** @module figtree */\n// const d3 = require(\"d3\");\n\n/**\n * The FigTree class\n *\n * A class that takes a tree and draws it into the the given SVG root element. Has a range of methods\n * for adding interactivity to the tree (e.g., mouse-over labels, rotating nodes and rerooting on branches).\n * The tree is updated with animated transitions.\n */\nexport class FigTree extends d3Plot{\n\n    static DEFAULT_SETTINGS() {\n        return {\n            xAxisTickArguments: [5, \"f\"],\n            xAxisTitle: \"Divergence\",\n            // nodeRadius: 6,\n            hoverBorder: 2,\n            backgroundBorder: 0,\n            baubles: [],\n            transitionDuration:0,\n            opacityFunc:e=>1,\n        };\n    }\n\n    /**\n     * The constructor.\n     * @param svg\n     * @param layout - an instance of class Layout\n     * @param margins\n     * @param settings\n     */\n    constructor(svg, layout, margins, settings = {}) {\n        super();\n        this.layout = layout;\n        this.margins = margins;\n\n        // merge the default settings with the supplied settings\n        this.settings = {...FigTree.DEFAULT_SETTINGS(), ...settings};\n        this.svg=svg;\n        this.updateStyles=[];\n    }\n    draw(){\n        \n        // get the size of the svg we are drawing on\n        let width,height;\n        if(Object.keys(this.settings).indexOf(\"width\")>-1){\n            width =this. settings.width;\n        }else{\n            width = this.svg.getBoundingClientRect().width;\n        }\n        if(Object.keys(this.settings).indexOf(\"height\")>-1){\n            height =this.settings.height;\n        }else{\n            height = this.svg.getBoundingClientRect().height;\n        }\n\n        //remove the tree if it is there already\n        select(this.svg).select(\"g\").remove();\n\n        // add a group which will contain the new tree\n        select(this.svg).append(\"g\")\n            .attr(\"transform\",`translate(${this.margins.left},${this.margins.top})`);\n\n        //to selecting every time\n        this.svgSelection = select(this.svg).select(\"g\");\n\n        this.svgSelection.append(\"g\").attr(\"class\", \"axes-layer\");\n        this.svgSelection.append(\"g\").attr(\"class\", \"branches-layer\");\n        if (this.settings.backgroundBorder > 0) {\n            this.svgSelection.append(\"g\").attr(\"class\", \"nodes-background-layer\");\n        }\n        this.svgSelection.append(\"g\").attr(\"class\", \"nodes-layer\");\n\n        // create the scales\n        const xScale = scaleLinear()\n            .domain(this.layout.horizontalRange)\n            .range([this.margins.left, width - this.margins.right]);\n\n        const yScale = scaleLinear()\n            .domain(this.layout.verticalRange)\n            .range([this.margins.top + 20, height -this.margins.bottom - 20]);\n\n        this.scales = {x:xScale, y:yScale, width, height};\n        addAxis.call(this, this.margins);\n\n        this.vertices = [];\n        this.edges = [];\n\n        // Called whenever the layout changes...\n        this.layout.updateCallback = () => {\n            this.update();\n        }\n\n        this.update();\n        // this.update();\n    }\n\n    /**\n     * Updates the tree when it has changed\n     */\n    update() {\n\n        // get new positions\n        this.layout.layout(this.vertices, this.edges);\n        // svg may have changed sizes\n        let width,height;\n        if(Object.keys(this.settings).indexOf(\"width\")>-1){\n            width =this. settings.width;\n        }else{\n            width = this.svg.getBoundingClientRect().width;\n        }\n        if(Object.keys(this.settings).indexOf(\"height\")>-1){\n            height =this. settings.height;\n        }else{\n            height = this.svg.getBoundingClientRect().height;\n        }\n\n        // update the scales' domains\n        this.scales.x.domain(this.layout.horizontalRange).range([this.margins.left, width - this.margins.right]);\n        this.scales.y.domain(this.layout.verticalRange).range([this.margins.top + 20, height -this. margins.bottom - 20]);\n        this.scales.width=width;\n        this.scales.height=height;\n\n        // updateAxis.call(this);\n        const xAxis = axisBottom(this.scales.x)\n            .tickArguments(this.settings.xAxisTickArguments);\n\n        this.svgSelection.select(\"#x-axis\")\n            .transition()\n            .duration(this.settings.transitionDuration)\n            .call(xAxis);\n\n\n        // call the private methods to create the components of the diagram\n\n        if (this.settings.backgroundBorder > 0) {\n            updateNodeBackgrounds.call(this);\n        }\n\n        updateNodes.call(this);\n        updateBranches.call(this);\n        updateBranches.call(this);\n\n    }\n\n\n    /**\n     * set mouseover highlighting of branches\n     */\n    hilightBranches() {\n        // need to use 'function' here so that 'this' refers to the SVG\n        // element being hovered over.\n        const self=this;\n        const selected = this.svgSelection.selectAll(\".branch\").select(\".branch-path\");\n        selected.on(\"mouseover\", function (d, n,i) {\n            select(this).classed(\"hovered\", true);\n            console.log(self)\n\n        });\n        selected.on(\"mouseout\", function (d, i) {\n            select(this).classed(\"hovered\", false);\n\n        });\n    }\n\n    /**\n     * Set mouseover highlighting of internal nodes\n     */\n    hilightInternalNodes() {\n        this.hilightNodes(\".internal-node\");\n    }\n\n    /**\n     * Set mouseover highlighting of internal nodes\n     */\n    hilightExternalNodes() {\n        this.hilightNodes(\".external-node\");\n    }\n\n    /**\n     * Set mouseover highlighting of nodes\n     */\n    hilightNodes(selection) {\n        // need to use 'function' here so that 'this' refers to the SVG\n        // element being hovered over.\n        const self = this;\n        const selected = this.svgSelection.selectAll(selection);\n        selected.on(\"mouseover\", function (d, i) {\n            const node = select(this).select(\".node-shape\");\n            self.settings.baubles.forEach((bauble) => {\n                if (bauble.vertexFilter(node)) {\n                    bauble.updateShapes(node, self.settings.hoverBorder);\n                }\n            });\n\n            node.classed(\"hovered\", true);\n        });\n        selected.on(\"mouseout\", function (d, i) {\n            const node = select(this).select(\".node-shape\");\n\n            self.settings.baubles.forEach((bauble) => {\n                if (bauble.vertexFilter(node)) {\n                    bauble.updateShapes(node, 0);\n                }\n            });\n\n            node.classed(\"hovered\", false);\n        });\n    }\n\n    /**\n     * Registers action function to be called when an edge is clicked on. The function is passed\n     * edge object that was clicked on and the position of the click as a proportion of the edge length.\n     *\n     * Optionally a selection string can be provided - i.e., to select a particular branch by its id.\n     *\n     * @param action\n     * @param selection\n     */\n    onClickBranch(action, selection = null) {\n        // We need to use the \"function\" keyword here (rather than an arrow) so that \"this\"\n        // points to the actual SVG element (so we can use d3.mouse(this)). We therefore need\n        // to store a reference to the object in \"self\".\n        const self = this;\n        const selected = this.svgSelection.selectAll(`${selection ? selection : \".branch\"}`);\n        selected.on(\"click\", function (edge) {\n            const x1 = self.scales.x(edge.v1.x);\n            const x2 = self.scales.x(edge.v0.x);\n            const mx = mouse(this)[0];\n            const proportion = Math.max(0.0, Math.min(1.0, (mx - x2) / (x1 - x2)));\n            action(edge, proportion);\n        })\n    }\n\n    /**\n     * Registers action function to be called when an internal node is clicked on. The function should\n     * take the tree and the node that was clicked on.\n     *\n     * A static method - Tree.rotate() is available for rotating the node order at the clicked node.\n     *\n     * @param action\n     */\n    onClickInternalNode(action) {\n        this.onClickNode(action, \".internal-node\");\n    }\n\n    /**\n     * Registers action function to be called when an external node is clicked on. The function should\n     * take the tree and the node that was clicked on.\n     *\n     * @param action\n     */\n    onClickExternalNode(action) {\n        this.onClickNode(action, \".external-node\");\n    }\n\n    /**\n     * Registers action function to be called when a vertex is clicked on. The function is passed\n     * the vertex object.\n     *\n     * Optionally a selection string can be provided - i.e., to select a particular node by its id.\n     *\n     * @param action\n     * @param selection\n     */\n    onClickNode(action, selection = null) {\n        const selected = this.svgSelection.selectAll(`${selection ? selection : \".node\"}`).select(\".node-shape\");        \n        const self=this;\n        selected.on(\"click\", (d,i,n) => {\n            action(d,i,n,self);\n        })\n    }\n    /**\n     * General Nodehover callback\n     * @param {*} action and object with an enter and exit function\n     * @param {*} selection defualts to \".node\" will select this selection's child \".node-shape\"\n     */\n\n    onHoverNode(action,selection=null){\n        const self = this;\n        const selected = this.svgSelection.selectAll(`${selection ? selection : \".node\"}`).select(\".node-shape\");        \n        selected.on(\"mouseover\", (d,i,n) => {\n            action.enter(d,i,n,self);\n        });\n        selected.on(\"mouseout\", (d,i,n) => {\n            action.exit(d,i,n,self);\n        });\n    }\n\n    /**\n     * General branch hover callback\n     * @param {*} action and object with an enter and exit function\n     * @param {*} selection defualts to .branch\n     */\n    onHoverBranch(action){ \n        // need to use 'function' here so that 'this' refers to the SVG\n        // element being hovered over.\n        const self=this;\n        const selected = this.svgSelection.selectAll(\".branch\").select(\".branch-path\");\n        selected.on(\"mouseover\", function (d, i,n) {\n            action.enter(d,i,n,self);\n\n        });\n        selected.on(\"mouseout\", function (d, i, n) {\n            action.exit(d,i,n,self);\n        });\n    }\n    /**\n     * Registers some text to appear in a popup box when the mouse hovers over the selection.\n     *\n     * @param selection\n     * @param text\n     */\n    addToolTip(selection, text) {\n        this.svgSelection.selectAll(selection).on(\"mouseover\",\n            function (selected) {\n                let tooltip = document.getElementById(\"tooltip\");\n                if (typeof text === typeof \"\") {\n                    tooltip.innerHTML = text;\n                } else {\n                    tooltip.innerHTML = text(selected.node);\n                }\n                tooltip.style.display = \"block\";\n                tooltip.style.left =event.pageX + 10 + \"px\";\n                tooltip.style.top = event.pageY + 10 + \"px\";\n            }\n        );\n        this.svgSelection.selectAll(selection).on(\"mouseout\", function () {\n            let tooltip = document.getElementById(\"tooltip\");\n            tooltip.style.display = \"none\";\n        });\n    }\n\n    set treeLayout(layout) {\n        this.layout = layout;\n        this.update();\n    }\n\n    // Highlight a node in the graph given the node id\n    highlightNode(nodeId, classString){\n        const nodeGroup =  this.svgSelection.select(`.node.id-${nodeId}`)\n        const nodeShape = nodeGroup.select(\".node-shape\");\n        nodeGroup.raise(); //da roof - bring to the top of the g groups.\n        this.settings.baubles.forEach((bauble) => {\n            if (bauble.vertexFilter(nodeShape)) {\n                bauble.updateShapes(nodeShape, this.settings.hoverBorder);\n            }\n        });\n        nodeShape.classed(classString, true);\n    }\n    unHighlightNode(nodeId,classString){\n        const nodeGroup =  this.svgSelection.select(`.node.id-${nodeId}`)\n        const nodeShape = nodeGroup.select(\".node-shape\");\n        nodeGroup.raise(); //da roof - bring to the top of the g groups.\n        this.settings.baubles.forEach((bauble) => {\n            if (bauble.vertexFilter(nodeShape)) {\n                bauble.updateShapes(nodeShape, 0);\n            }\n        });\n        nodeShape.classed(classString, false);\n    }\n    \n}\n\n/*\n * Private methods, called by the class using the <function>.call(this) function.\n */\n\n/**\n * Adds or updates nodes\n */\nfunction updateNodes() {\n\n    const nodesLayer = select(this.svg).select(\".nodes-layer\");\n\n    // DATA JOIN\n    // Join new data with old elements, if any.\n    const nodes = nodesLayer.selectAll(\".node\")\n        .data(this.vertices, (v) => `n_${v.key}`);\n\n    // ENTER\n    // Create new elements as needed.\n    const newNodes = nodes.enter().append(\"g\")\n        .attr(\"id\", (v) => v.id)\n        .attr(\"class\", (v) => [\"node\", ...v.classes].join(\" \"))\n        .attr(\"transform\", (v) => {\n            return `translate(${this.scales.x(v.x)}, ${this.scales.y(v.y)})`;\n        });\n\n    // add the specific node shapes or 'baubles'\n    this.settings.baubles.forEach((bauble) => {\n        const d = bauble\n            .createShapes(newNodes.filter(bauble.vertexFilter))\n            .attr(\"class\", \"node-shape\");\n        bauble.updateShapes(d);\n    });\n\n    // newNodes.append(\"text\")\n    //     .attr(\"class\", \"node-label name\")\n    //     .attr(\"text-anchor\", \"start\")\n    //     .attr(\"alignment-baseline\", \"middle\")\n    //     .attr(\"dx\", \"12\")\n    //     .attr(\"dy\", \"0\")\n    //     .text((d) => d.rightLabel);\n\n    // newNodes.append(\"text\")\n    //     .attr(\"class\", \"node-label support\")\n    //     .attr(\"text-anchor\", \"end\")\n    //     .attr(\"dx\", \"-6\")\n    //     .attr(\"dy\", d => (d.labelBelow ? -8 : +8))\n    //     .attr(\"alignment-baseline\", d => (d.labelBelow ? \"bottom\": \"hanging\" ))\n    //     .text((d) => d.leftLabel);\n\n    // update the existing elements\n    nodes\n        .transition()\n        .duration(this.settings.transitionDuration)\n        .attr(\"class\", (v) => [\"node\", ...v.classes].join(\" \"))\n        .attr(\"transform\", (v) => {\n            return `translate(${this.scales.x(v.x)}, ${this.scales.y(v.y)})`;\n        });\n\n    // update all the baubles\n    this.settings.baubles.forEach((bauble) => {\n        const d = nodes.select(\".node-shape\")\n            .filter(bauble.vertexFilter)\n            .transition()\n            .duration(this.settings.transitionDuration);\n        bauble.updateShapes(d)\n    });\n\n    // nodes.select(\"text .node-label .name\")\n    //     .transition()\n    //     .duration(this.settings.transitionDuration)\n    //     .attr(\"class\", \"node-label name\")\n    //     .attr(\"text-anchor\", \"start\")\n    //     .attr(\"alignment-baseline\", \"middle\")\n    //     .attr(\"dx\", \"12\")\n    //     .attr(\"dy\", \"0\")\n    //     .text((d) => d.rightLabel);\n\n    // nodes.select(\"text .node-label .support\")\n    //     .transition()\n    //     .duration(this.settings.transitionDuration)\n    //     .attr(\"alignment-baseline\", d => (d.labelBelow ? \"bottom\": \"hanging\" ))\n    //     .attr(\"class\", \"node-label support\")\n    //     .attr(\"text-anchor\", \"end\")\n    //     .attr(\"dx\", \"-6\")\n    //     .attr(\"dy\", d => (d.labelBelow ? -8 : +8))\n    //     .text((d) => d.leftLabel);\n\n    // EXIT\n    // Remove old elements as needed.\n    nodes.exit().remove();\n\n}\n\nfunction updateNodeBackgrounds() {\n\n    const nodesBackgroundLayer = this.svgSelection.select(\".nodes-background-layer\");\n\n    // DATA JOIN\n    // Join new data with old elements, if any.\n    const nodes = nodesBackgroundLayer.selectAll(\".node-background\")\n        .data(this.vertices, (v) => `nb_${v.key}`);\n\n    // ENTER\n    // Create new elements as needed.\n    const newNodes = nodes.enter();\n\n    // add the specific node shapes or 'baubles'\n    this.settings.baubles.forEach((bauble) => {\n        const d = bauble\n            .createShapes(newNodes.filter(bauble.vertexFilter))\n            .attr(\"class\", v=>[\"node-background\", ...v.classes].join(\" \"))\n            .attr(\"transform\", (v) => {\n                return `translate(${this.scales.x(v.x)}, ${this.scales.y(v.y)})`;\n            });\n\n        bauble.updateShapes(d, this.settings.backgroundBorder);\n    });\n\n    // update all the existing elements\n    this.settings.baubles.forEach((bauble) => {\n        const d = nodes\n            .filter(bauble.vertexFilter)\n            .transition()\n            .duration(this.settings.transitionDuration)\n            .attr(\"transform\", (v) => {\n                return `translate(${this.scales.x(v.x)}, ${this.scales.y(v.y)})`;\n            });\n        bauble.updateShapes(d, this.settings.backgroundBorder)\n    });\n\n    // EXIT\n    // Remove old elements as needed.\n    nodes.exit().remove();\n\n}\n\n\n/**\n * Adds or updates branch lines\n */\nfunction updateBranches() {\n    \n    const branchesLayer = this.svgSelection.select(\".branches-layer\");\n\n    // a function to create a line path\n    // const branchPath = d3.line()\n    //     .x((v) => v.x)\n    //     .y((v) => v.y)\n    //     .curve(this.layout.branchCurve);\n    const branchPath = this.layout.branchPathGenerator(this.scales)\n\n    // DATA JOIN\n    // Join new data with old elements, if any.\n    const branches = branchesLayer.selectAll(\"g .branch\")\n        .data(this.edges, (e) => `b_${e.key}`);\n\n    // ENTER\n    // Create new elements as needed.\n    const newBranches = branches.enter().append(\"g\")\n        .attr(\"id\", (e) => e.id)\n        .attr(\"opacity\",e=>this.settings.opacityFunc(e))\n        .attr(\"class\", (e) => [\"branch\", ...e.classes].join(\" \"))\n        .attr(\"transform\", (e) => {\n            return `translate(${this.scales.x(e.v0.x)}, ${this.scales.y(e.v1.y)})`;\n        });\n\n    newBranches.append(\"path\")\n        .attr(\"class\", \"branch-path\")\n        .attr(\"d\", (e,i) => { branchPath(e,i)});\n\n    \n\n    newBranches.append(\"text\")\n        .attr(\"class\", \"branch-label length\")\n        .attr(\"dx\", (e) => ((this.scales.x(e.v1.x) - this.scales.x(e.v0.x)) / 2))\n        .attr(\"dy\", (e) => (e.labelBelow ? +6 : -6))\n        .attr(\"alignment-baseline\", (e) => (e.labelBelow ? \"hanging\" : \"bottom\"))\n        .attr(\"text-anchor\", \"middle\")\n        .text((e) => e.label);\n\n    // update the existing elements\n    branches\n        .transition()\n        .duration(this.settings.transitionDuration)\n        .attr(\"class\", (e) => [\"branch\", ...e.classes].join(\" \"))\n        .attr(\"transform\", (e) => {\n            return `translate(${this.scales.x(e.v0.x)}, ${this.scales.y(e.v1.y)})`;\n        })\n        .select(\"path\")\n        .attr(\"d\", (e,i) => branchPath(e,i))\n        .select(\"text .branch-label .length\")\n        .attr(\"class\", \"branch-label length\")\n        .attr(\"dx\", (e) => ((this.scales.x(e.v1.x) - this.scales.x(e.v0.x)) / 2))\n        .attr(\"dy\", (e) => (e.labelBelow ? +6 : -6))\n        .attr(\"alignment-baseline\", (e) => (e.labelBelow ? \"hanging\" : \"bottom\"))\n        .attr(\"text-anchor\", \"middle\")\n        .attr(\"opacity\",e=>this.settings.opacityFunc(e))\n        .text((e) => e.label);\n\n    // EXIT\n    // Remove old elements as needed.\n    branches\n        .exit().remove();\n}\n\n/**\n * Add axis\n */\nfunction addAxis() {\n    const xAxis = axisBottom(this.scales.x)\n        .tickArguments(this.settings.xAxisTickArguments);\n\n    const xAxisWidth = this.scales.width - this.margins.left - this.margins.right;\n\n    const axesLayer = this.svgSelection.select(\".axes-layer\");\n\n    axesLayer\n        .append(\"g\")\n        .attr(\"id\", \"x-axis\")\n        .attr(\"class\", \"axis\")\n        .attr(\"transform\", `translate(0, ${this.scales.height - this.margins.bottom + 5})`)\n        .call(xAxis);\n\n    axesLayer\n        .append(\"g\")\n        .attr(\"id\", \"x-axis-label\")\n        .attr(\"class\", \"axis-label\")\n        .attr(\"transform\", `translate(${this.margins.left}, ${this.scales.height - this.margins.bottom})`)\n        .append(\"text\")\n        .attr(\"transform\", `translate(${xAxisWidth / 2}, 35)`)\n        .attr(\"alignment-baseline\", \"hanging\")\n        .style(\"text-anchor\", \"middle\")\n        .text(this.settings.xAxisTitle);\n}\n\n","\"use strict\"\n/** @module Graph */\n\n// import {Type}  from '../lib/figtree.js/index.js';\n/**\n * The graph class\n *\n * A class that takes an arrary of nodes and edges and provides a number of methods\n * for manipulating the graph.\n * @param nodes - an array of nodes. Should contain a unique id identifier\n * @param edges - an array of edges linking the nodes {source:node.id,target:node.id}\n */\nexport class Graph{\n    constructor(nodes=[],edges=[],settings={acyclicSelector:(e)=>true}) {\n        \n        this.nodeList = [];\n        this.nodeMap = new Map();\n        this.outGoingEdgeMap = new Map();\n        this.incomingEdgeMap= new Map();\n        this.edgeList = [];\n        this.edgeMap = new Map();  \n        this.acyclicSelector=settings.acyclicSelector;\n\n\n        nodes.forEach(node=>this.addNode(node));\n        edges.forEach(edge=> {\n                            const metaData = edge.metaData? edge.metaData:{};\n                           \n                            this.drawEdge(edge.source,edge.target,metaData)\n        });\n        // This is used in identifying terminal tips  \n    };\n    /**\n     * A static function to make a graph out of a tree\n     * @param {*} tree \n     * @returns {Graph}\n     */\n    static fromPhylogeny(tree){\n        const nodes = tree.externalNodes;\n        // links inferred from the transmission layout\n        // will also need a call back somewhere to update the links\n        \n    }\n    /**\n     * @returns {*}\n     */\n    get nodes(){\n        return this.nodeList;\n    }\n    /**\n     * @returns {*}\n     */\n    get externalNodes(){\n        return this.nodeList.filter(d=>this.getOutgoingEdges().length===0);\n    }\n    /**\n     * Adds a node to the graph.\n     * @param {*} node \n     */\n    addNode(node){\n        if(!node.id){\n            throw new Error(`All node's must contain an 'id' key ${node}`)\n        }\n        this.nodeList.push(node);\n        if(this.nodeMap.has(node.id)){\n            throw new Error(`All node's must have unique id values ${node.id} seen twice`)\n        }\n        this.nodeMap.set(node.id,node);\n\n        this.outGoingEdgeMap.set(node,[]);\n        this.incomingEdgeMap.set(node,[]);\n    }\n   \n   /**\n    * return a node given the key\n    * @param {*} id the node id value \n    */\n    getNode(id){\n        return this.nodeMap.get(id);\n    }\n    \n    /**\n     * Get the edges entering a node\n     * @param {*} node \n     * @returns {array} array of edges that end with the node\n     */\n    getIncomingEdges(node){\n        return this.incomingEdgeMap.get(node)\n     }\n     /**\n      * Get the edges leaving a node\n      * @param {*} node \n      * @returns {array} array of edges that begin with the node\n      */\n \n     getOutgoingEdges(node){\n         return this.outGoingEdgeMap.get(node)\n     }\n     /**\n      * Get all the edges leaving and entering a node\n      * @param {*} node\n      * @returns {array} array of edges that touch node\n      */\n     getEdges(node){\n         return (this.getOutgoingEdges(node).concat(this.getIncomingEdges(node)));\n     }\n\n    getNodeInfo(node){\n        // const formatDate=d3.timeFormat(\"%Y-%m-%d\")\n        // let outString = `${node.id} </br>`\n        // // for(const key of Object.keys(node)){\n        // //     if(node[key]){\n        // //         if(key!==\"id\"&& key!==\"metaData\"&&key!==\"key\"){\n        // //             if(key.toLowerCase().indexOf(\"date\")>-1){\n        // //                 outString = `${outString}${key}: ${node[key].toISOString().substring(0, 10)}</br>`;\n        // //                 }else{\n        // //                 outString = `${outString}${key}: ${node[key]}</br>`;\n        // //                 }            \n        // //             }\n        // //     }\n        // // }\n    \n        // for(const key of Object.keys(node.metaData)){\n        //     if(key.toLowerCase().indexOf(\"date\")>-1){\n        //     outString = `${outString}${key}: ${node.metaData[key].toISOString().substring(0, 10)}</br>`;\n        //     }else{\n        //     outString = `${outString}${key}: ${node.metaData[key]}</br>`;\n        //     }\n        // }\n        // return outString;\n    }\n\n    /**\n     * removes the node and incoming/outgoing edges\n     * @param {object} node \n     */\n   \n    removeNode(node){\n        //remove edges\n        const edges = this.getEdges(node);\n        edges.forEach(edge=>this.removeEdge(edge))\n\n        const id=node.id\n        this.nodeList=this.nodeList.filter(node=>node.id!==id);\n        this.nodeMap.delete(id);\n        this.incomingEdgeMap.delete(node);\n        this.outGoingEdgeMap.delete(node);\n    }\n\n    /**\n    * @returns {*} \n    */\n    get edges(){\n    return this.edgeList;\n    }\n    \n    /**\n     * returns the edge\n     * @param {Symbol()} id - symbol key of the edge\n     * @returns {*} edge\n     */\n    getEdge(id){\n        return this.edgeMap.get(id);\n    }\n    getEdgeInfo(edge){\n        // // const formatDate=d3.timeFormat(\"%Y-%m-%d\")\n        // let outString = `Source:${edge.source.id} </br> Target: ${edge.target.id}</br>`;\n        // for(const key of Object.keys(edge.metaData)){\n        //     if(key.toLowerCase().indexOf(\"date\")>-1){\n        //     outString = `${outString}${key}: ${edge.metaData[key].toISOString().substring(0, 10)}</br>`;\n        //     }else{\n        //     outString = `${outString}${key}: ${edge.metaData[key]}</br>`;\n        //     }\n        // }\n        // return outString;\n    }\n     /**\n     * Adds an edge between the provide source and target nodes. It the nodes are not part of the graph they are added.\n     * @param {String} sourceNode Id\n     * @param {String} targetNode Id\n     */\n    drawEdge(sourceNodeId,targetNodeId,metaData={}){\n        if(!this.nodeMap.has(sourceNodeId)){\n            throw new Error(`${sourceNodeId} not found in graph`)\n        }\n        if(!this.nodeMap.has(targetNodeId)){\n            throw new Error(`${targetNodeId} not found in graph`)\n        }\n        const index = this.edgeList.length;\n        const edge = {source:this.getNode(sourceNodeId),target:this.getNode(targetNodeId),id:`edge_${index}`,metaData:metaData};\n        this.addEdge(edge);\n    }\n    /**\n     * Adds an premade edge which between the provide source and target nodes. It the nodes are not part of the graph they are added.\n     * @param {*} {source:node, targe:node} \n     */\n    addEdge(edge){\n        this.edgeList.push(edge);\n        this.edgeMap.set(edge.id,edge);\n        this.outGoingEdgeMap.get(edge.source).push(edge);\n        this.incomingEdgeMap.get(edge.target).push(edge);\n    }\n    \n\n    /**\n     * removes an edge from the graph\n     * @param {*} edge \n     */\n    removeEdge(edge){\n        const id=edge.id\n        this.edgeList=this.edgeList.filter(edge=>edge.id!==id);\n\n        // update edgemaps\n        this.edgeMap.delete(id)\n        // new outgoing\n        const newOutgoing = this.getOutgoingEdges(edge.source).filter(e=>e!==edge);\n        this.outGoingEdgeMap.set(edge.source,newOutgoing);\n        const newIncoming = this.getIncomingEdges(edge.target).filter(e=>e!==edge);\n        this.incomingEdgeMap.set(edge.target,newIncoming);\n\n    }\n\n\n    /**\n     * Inserts a node into an edge. This replaced the edge with two new edges which pass through the node.\n     * @param {*} node \n     * @param {*} edge \n     */\n    insertNode(node,edge){\n        if(!this.nodeMap.has(node.id)){\n            this.addNode(node)\n        }\n        this.drawEdge(edge.source.id,node.id);\n        this.drawEdge(node.id,edge.target.id);\n        this.removeEdge(edge)\n    }\n\n    /**\n     * A function to return a sub graph given an arrary of nodes.\n     * @param {array} nodes - An array of nodes\n     * @param {*} options - an optional object with filterEdges:function() that filters the edges used in the traversal\n     * @returns {*} A graph object including the provided nodes and edges linking the node. If there is no path between all nodes the \n     * object will be empty \n     */\n    getSubGraph(index,options={filterEdges:(e)=>true}){\n\n                \n        \n        // return new Graph();\n\n        // nodes,uniqueEdges)\n       \n    }\n\n        /**\n     * A function returning \n     * @param {*} nodes - An array of nodes\n     * @param {*} options - an optional object with filterEdges:function() that filters the edges used in the traversal\n     * @returns {*} \n     * Not yet implimented. Should each path be a sub-graph?\n     */\n    getPaths(node1,node2,options={filterEdges:(e)=>true}){\n        // check there is a path between all nodes\n        throw new Error(\"Not yet implimented\");\n\n       \n    }\n\n// -----------  Methods rejigged from figtree.js tree object -----------------------------\n    /**\n     * Reverses the order of the children of the given node. If 'recursive=true' then it will\n     * descend down the subtree reversing all the sub nodes.\n     *\n     * @param node\n     * @param recursive\n     */\n    // add options with edgeFilter callback\n    rotate(node, options={recursive:false}) {\n        const nodesToVisit = [...this.preorder(node)];\n        const outGoingEdges=this.getOutgoingEdges(node);\n\n            if (options.recursive) {\n                for (const n of nodesToVisit) {\n                    //Needs to avoid circulare loops \n                    const nOutGoingEdges=this.getOutgoingEdges(n);\n                    nOutGoingEdges.reverse();\n                }\n            }else{\n                outGoingEdges.reverse();\n\n            }\n        };\n\n    /**\n     * Sorts the child branches of each node in order of increasing or decreasing number\n     * of tips. This operates recursively from the node given.\n     *\n     * @param node - the node to start sorting from\n     * @param {boolean} increasing - sorting in increasing node order or decreasing?\n     * @returns {number} - the number of tips below this node\n     */\n    order(node, increasing) {\n        // // orderNodes.call(this, node, increasing, this.treeUpdateCallback);\n        // orderNodes.call(this, node,increasing);\n        // // this.treeUpdateCallback();\n    }\n\n\n    /**\n     * A generator function that returns the nodes in a pre-order traversal. Starting at \n     * node. An optional options objects can be used to select which edges are used in the traversal\n     * @param {*} node \n     * @param {object} options - an optional object with filterEdges:function() that filters the edges used in the traversal\n     * @returns {IterableIterator<IterableIterator<*|*>>}\n     */\n    *preorder(node) {\n        // We have to mark nodes as visited since it is possible to cycle back\n        this.edgeList.forEach(e=>e.visited=false);\n        this.nodeList.forEach(n => n.visited=false);\n        const self = this;\n        const traverse = function *(node){\n            yield node;\n            const edges = self.getEdges(node).filter(e=>self.acyclicSelector(e));\n            // don't need all this if using acyclic edges\n            if(edges.length>0){\n                for(const edge of edges){\n                    if(!edge.visited){\n                        let nextNode;\n                        if(node===edge.source){\n                            nextNode = edge.target;\n                        }else{\n                            nextNode=edge.source;\n                        }\n                        if(!nextNode.visited){\n                            edge.visited=true;\n                            yield* traverse(nextNode);\n                        }else{\n                            edge.visited=true; // technically a back edge\n                        }\n                    }\n                }\n            }\n        };\n        yield* traverse(node);\n        this.edgeList.forEach(e=> delete e[\"visited\"]);\n        this.nodeList.forEach(n => delete n[\"visited\"]);\n    }\n\n    /**\n     * A generator function that returns the nodes in a post-order traversal. Starting at \n     * node. An optional options objects can be used to select which edges are used in the traversal\n     * @param {*} node \n     * @param {object} options - an optional object with filterEdges:function() that filters the edges used in the traversal\n     * @returns {IterableIterator<IterableIterator<*|*>>}\n     */\n    *postorder(node) {\n        // We have to mark nodes as visited since it is possible to cycle back\n        this.edgeList.forEach(e=>e.visited=false);\n        this.nodeList.forEach(n => n.visited=false);\n        const self=this;\n        const traverse = function *(node){\n            const edges = self.getEdges(node).filter(e=>self.acyclicSelector(e));\n            // don't need all this if using acyclic edges\n            if(edges.length>0){\n                for(const edge of edges){\n                    if(!edge.visited){\n                        let nextNode;\n                        if(node===edge.source){\n                            nextNode = edge.target;\n                        }else{\n                            nextNode=edge.source;\n                        }\n                        if(!nextNode.visited){\n                            edge.visited=true;\n                            yield* traverse(nextNode);\n                        }else{\n                            edge.visited=true; // technically a back edge\n                        }\n                    }\n                }  \n            }\n            yield node;\n\n        };\n        yield* traverse(node);\n        this.edgeList.forEach(e=> delete e[\"visited\"]);\n        this.nodeList.forEach(n => delete n[\"visited\"]);\n    }\n\n}\n/*\n * Private methods, called by the class using the <function>.call(this) function.\n */\n\n/**\n * A private recursive function that rotates nodes to give an ordering.\n * @param node\n * @param increasing\n * @param callback an optional callback that is called each rotate\n * @returns {number}\n */\nfunction orderNodes(node, increasing, callback = null) {\n    // const factor = increasing ? 1 : -1;\n    // let count = 1;\n    // const pathsOut=this.getOutgoingEdges(node);\n    // if (pathsOut.length>0) {\n    //     const counts = new Map();\n    //     for (const child of pathsOut.map(e=>e.target) ) {\n    //         const value = orderNodes.call(this,child, increasing, callback);\n    //         counts.set(child, value);\n    //         count += value;\n    //     }\n    //     console.log(counts)\n    //     pathsOut.sort((a, b) => {\n    //         return (counts.get(a.target) - counts.get(b.target)) * factor\n    //     });\n\n    //     if (callback) callback();\n    // } else {\n    //     count = 1\n    // }\n    // return count;\n}\n\n","import {scaleLinear} from 'd3-scale';\nimport {Type} from '../figtree.js/index.js';\nimport { nextTick } from 'q';\n/**\n * The Layout class\n *\n */\nexport class d3PlotLayout {\n    static DEFAULT_SETTINGS() {\n        return {\n            horizontalRange:null,\n            horizontalTicks:null,\n            horizontalScale:scaleLinear,\n        }\n    }\n    /**\n     * The constructor.\n     */\n    constructor(data,settings={} ) {\n        this.data = data;\n        this.settings = {...d3PlotLayout.DEFAULT_SETTINGS(),...settings}\n        // default ranges - these should be set in layout()\n        this._horizontalRange = [0.0, 1.0];\n        this._verticalRange = [0, 1.0];\n        this._horizontalTicks= this.settings.horizontalScale()\n        .domain(this._horizontalRange).ticks(5)\n        // create an empty callback function\n        this.updateCallback = () => { };\n        this.annotations = {};\n\n    }\n\n    /**\n     * An abstract base class for a layout class. The aim is to describe the API of the class.\n     *\n     * @param ...params  objects that will be udated with positions. Could be empty\n     */\n    layout(params) { }\n\n    get horizontalRange() {\n        return this._horizontalRange;\n    }\n\n    get verticalRange() {\n        return this._verticalRange;\n    }\n    get horizontalAxisTicks(){\n        return this._horizontalTicks;\n    }\n\n    /**\n     * Updates the tree when it has changed\n     */\n    update() {\n        this.updateCallback();\n    }\n\n    /**\n     * Adds the given annotations to a particular node object.\n     *\n     * The annotations is an object with properties keyed by external node labels each\n     * of which is an object with key value pairs for the annotations. The\n     * key value pairs will be added to a property called 'annotations' in the node.\n     *\n     * Boolean or Numerical traits are given as a single value.\n     * Sets of values with probabilities should be given as an object.\n     * Discrete values should be given as an array (even if containing only one value)\n     * or an object with booleans to give the full set of possible trait values.\n     *\n     * For example:\n     *\n     * {\n     *     'tip_1': {\n     *         'trait_1' : true,\n     *         'trait_4' : 3.141592,\n     *         'trait_2' : [1, 2], // discrete trait\n     *         'trait_3' : [\"London\", \"Paris\", \"New York\"], // discrete trait\n     *         'trait_3' : {\"London\" : true, \"Paris\" : false, \"New York\": false], // discrete trait with full set of values\n     *         'trait_4' : {\"London\" : 0.75, \"Paris\" : 0.20, \"New York\": 0.05} // probability set\n     *     },\n     *     'tip_2': {...}\n     * }\n     *\n     * The annotation labels, type and possible values are also added to the tree in a property called 'annotations'.\n     *\n     * A reconstruction method such as annotateNodesFromTips can then be used to provide reconstructed values\n     * for internal nodes. Or annotateNodes can provide annotations for any node in the tree.\n     *\n     * @param data\n     * @param annotations a dictionary of annotations keyed by the annotation name.\n     */\n    // annotateData(data) {\n    //     if(data.annotations){\n    //         console.log(data.annotations)\n    //     this.addAnnotations(data.annotations);\n    //     }else{\n    //         this.addAnnotations(data);\n    //     }\n    //     //Get data Entries in annotations\n    //     const annotatedEntries = Object.keys(data).filter(k=>Object.keys(this.annotations).indexOf(k)>-1);\n\n    //     // // add the annotations to the existing annotations object for the node object\n    //     data.annotations = {...(data.annotations === undefined ? {} : data.annotations), ...dataAnnotations};\n    // }\n\n    /**\n    * This methods also checks the values are correct and conform to previous annotations\n    * in type.\n    *\n    * @param annotations\n    */\n   addAnnotations(datum) {\n       for (let [key, addValues] of Object.entries(datum)) {\n           if(addValues instanceof Date||  typeof addValues === 'symbol'||addValues===null){\n               continue; // don't handel dates yet\n           }\n            let annotation = this.annotations[key];\n           if (!annotation) {\n               annotation = {};\n               this.annotations[key] = annotation;\n           }\n\n           if(typeof addValues === 'string' || addValues instanceof String){\n               // fake it as an array\n               addValues = [addValues];\n           }\n           if (Array.isArray(addValues)) {\n               // is a set of discrete values or \n               const type = Type.DISCRETE;\n\n               if (annotation.type && annotation.type !== type) {\n                   throw Error(`existing values of the annotation, ${key}, in the tree is not of the same type`);\n               }\n               annotation.type = type;\n               annotation.values = annotation.values? [...annotation.values, ...addValues]:[...addValues]\n           } else if (Object.isExtensible(addValues)) {\n               // is a set of properties with values               \n               let type = null;\n\n               let sum = 0.0;\n               let keys = [];\n               for (let [key, value] of Object.entries(addValues)) {\n                   if (keys.includes(key)) {\n                       throw Error(`the states of annotation, ${key}, should be unique`);\n                   }\n                   if (typeof value === typeof 1.0) {\n                       // This is a vector of probabilities of different states\n                       type = (type === undefined) ? Type.PROBABILITIES : type;\n\n                       if (type === Type.DISCRETE) {\n                           throw Error(`the values of annotation, ${key}, should be all boolean or all floats`);\n                       }\n\n                       sum += value;\n                       if (sum > 1.0) {\n                           throw Error(`the values of annotation, ${key}, should be probabilities of states and add to 1.0`);\n                       }\n                   } else if (typeof value === typeof true) {\n                       type = (type === undefined) ? Type.DISCRETE : type;\n\n                       if (type === Type.PROBABILITIES) {\n                           throw Error(`the values of annotation, ${key}, should be all boolean or all floats`);\n                       }\n                   } else {\n                       throw Error(`the values of annotation, ${key}, should be all boolean or all floats`);\n                   }\n                   keys.append(key);\n               }\n\n               if (annotation.type && annotation.type !== type) {\n                   throw Error(`existing values of the annotation, ${key}, in the tree is not of the same type`);\n               }\n\n               annotation.type = type;\n               annotation.values = annotation.values? [...annotation.values, ...addValues]:[...addValues]\n           } else {\n               let type = Type.DISCRETE;\n\n               if (typeof addValues === typeof true) {\n                   type = Type.BOOLEAN;\n               } else if (Number(addValues)) {\n                   type = (addValues % 1 === 0 ? Type.INTEGER : Type.FLOAT);\n               }\n\n               if (annotation.type && annotation.type !== type) {\n                   if ((type === Type.INTEGER && annotation.type === Type.FLOAT) ||\n                       (type === Type.FLOAT && annotation.type === Type.INTEGER)) {\n                       // upgrade to float\n                       type = Type.FLOAT;\n                   } else {\n                       throw Error(`existing values of the annotation, ${key}, in the tree is not of the same type`);\n                   }\n               }\n\n               if (type === Type.DISCRETE) {\n                   if (!annotation.values) {\n                       annotation.values = new Set();\n                   }\n                   console.log(addValues)\n                    annotation.values.add(addValues);\n                \n               }\n\n               annotation.type = type;\n           }\n\n           // overwrite the existing annotation property\n           this.annotations[key] = annotation;\n       }\n   }\n}","import {max,min} from \"d3-array\";\nimport {nest} from \"d3-collection\";\nimport {timeWeek} from \"d3-time\"\nimport {scaleLinear} from 'd3-scale';\nimport {transition} from \"d3-transition\"\nimport {Type} from \"../figtree.js/index.js\";\nimport {d3PlotLayout} from \"./d3PlotLayout\";\n\n/**\n * StackedHistogram layout\n * settings\n */\nexport class stackedHistogramLayout extends d3PlotLayout{\n    static DEFAULT_SETTINGS() {\n        return {\n            groupingFunction:d=>1,\n            binnedFunction:d=>timeWeek.floor(d.symptomOnset),\n            keyToXFunction:{x0:d=>timeWeek(new Date(d.key)),x1: d=>timeWeek.offset(new Date(d.key),1)},\n            horizontalRange:null,\n            horizontalTicks:null,\n            horizontalScale:scaleLinear,\n            annotations:null\n        }\n    }\n\n    /**\n     * The constuctor\n     * @param {*} data which will be binned and  grouped\n     * @param {*} settings functions that will bin and group (color) the data\n     *                    groupingFunction:d=>1 - given the data assign it a group for coloring\n     *                    binnedFunction:d=>timeWeek.floor(d.symptomOnset), - given the data point return category for binning will be used as key in d3.nest\n     keyToXFunction:{x0:d=>timeWeek(new Date(d.key)), -given the key (from above) convert to x0 and x1 on axis.\n                                          x1: timeWeek.offset(new Date(d.key),1)\n     */\n    constructor(data,settings = { }){\n        super();\n        this.settings = {...stackedHistogramLayout.DEFAULT_SETTINGS(), ...settings};\n        this.data = data;\n        // default ranges - these should be set in layout()\n        this._horizontalRange = [0.0, 1.0];\n        this._verticalRange = [1.0, 0];\n        this._horizontalTicks= this.settings.horizontalScale()\n            .domain(this._horizontalRange).ticks(5)\n    }\n\n    /**\n     * Layout the data. Given a bins array population the arrary with one entry per datapoint with x0,x1 positions and y0,y1\n     * This will stack the data from each bin ordered by group.\n     * @param {*} bins\n     */\n    layout(bins){\n        const dateBins = nest().key(d=>timeWeek.floor(d.symptomOnset))\n            .entries(this.data)\n            .map(d=>({\"x0\":timeWeek(new Date(d.key)),\"x1\":timeWeek.offset(new Date(d.key),1),\"values\":d.values}));\n\n        //get the keys used to group the data within each bin\n\n        const groupKeys= this.data.map(d=>this.settings.groupingFunction(d)).reduce((acc,curr) =>{\n            if(acc.indexOf(curr)===-1){\n                acc.push(curr)\n            };\n            return(acc)},[]);\n\n        let currentCount=0;\n        let maxCount=0;\n        for(const time of dateBins){\n            currentCount=0;\n            for(const k of groupKeys){\n                const kEntry = time.values.filter(w=>this.settings.groupingFunction(w)===k);\n                const entry = {\"x0\":time.x0,\"x1\":time.x1,\"colorKey\":k}; // key is used for color\n                if(kEntry.length>0){\n                    for(const data of kEntry){\n                        const caseEntry = {...entry,...{\"data\":data}};\n                        // If there is annotations in the data add them here as classes\n                        // this.annotateData(data)\n                        this.addAnnotations(data)\n                        caseEntry.y0=currentCount;\n                        caseEntry.y1=currentCount+1;\n                        currentCount+=1;\n                        bins.push(caseEntry);\n                    }\n                }\n            }\n            maxCount=max([maxCount,currentCount])\n        }\n        if(!this.settings.horizontalRange){\n            this._horizontalRange = [min(dateBins,d=>d.x0),max(dateBins,d=>d.x1)];\n        }else{\n            this._horizontalRange=this.settings.horizontalRange;\n        }\n\n        if(!this.settings.horizontalTicks){\n            this._horizontalTicks= this.settings.horizontalScale()\n                .domain(this._horizontalRange).ticks(5)\n        }else{\n            this._horizontalTicks=this.settings.horizontalTicks;\n        }\n        this._verticalRange = [0,maxCount];\n\n    }\n\n    update() {\n        this.updateCallback();\n    }\n\n    get horizontalRange() {\n        return this._horizontalRange;\n    }\n\n    get verticalRange() {\n        return this._verticalRange;\n    }\n\n    get horizontalAxisTicks(){\n        return this._horizontalTicks;\n    }\n}\n\n","import React, {useRef,useEffect,useState} from 'react';\nimport {stackedHistogramChart} from '../lib/charts/stackedHistogram';\nimport {stackedHistogramLayout} from \"../lib/charts/stackedHistogramLayout\"\nimport {select} from \"d3-selection\";\nimport {scaleTime} from \"d3-scale\";\nimport {timeWeek} from \"d3-time\";\nimport {extent} from 'd3-array';\nimport {event,timeFormat} from 'd3';\n\nconst formatTime = timeFormat(\"%B %d, %Y\");\n\nconst mouseEnter = (d, i, n)=>{\n    select(n[i]).classed(\"hovered\", true);\n    // console.log(d)\n    let tooltip = document.getElementById(\"tooltip\");\n    // put text to display here!\n    tooltip.innerHTML =`Case Id: ${d.data.id}\n                        <br/>\n                        Location: ${d.data.location}\n                        <br/>\n                        Symptom onset: ${formatTime(d.data.symptomOnset)} `;\n\n    tooltip.style.display = \"block\";\n\n    // this should be dynamically set (i.e., the tooltip box should always be aligned to\n    // be visible in the view port).\n    tooltip.style.left = event.pageX + (event.pageX > 800? -300 : + 10) + \"px\";\n    tooltip.style.top = event.pageY + 10 + \"px\";\n\n    tooltip.style.visibility =\"visible\";\n};\n\nconst mouseExit = (d,i,n) => {\n    select(n[i]).classed(\"hovered\", false);\n    const tooltip = document.getElementById(\"tooltip\");\n    tooltip.style.visibility = \"hidden\";\n};\n\nconst callback = {enter:mouseEnter,exit:mouseExit};\n\nfunction StackedHistogram(props){\n    const [histogram,setHistogram]=useState(null);\n\n    const el = useRef();\n        useEffect(()=>{// make it the first time\n                // const layoutSettings = {\n                //     horizontalRange:extent(props.dateRange),\n                //     horizontalTicks:props.dateRange,\n                //     horizontalScale:scaleTime,\n                //     groupingFunction:d=>d.location};\n\n                // const layout = new stackedHistogramLayout(props.data,layoutSettings);\n                const settings = { hoverBorder: 4, backgroundBorder:0,tranitionDuration:0};\n                select(el.current).select('g').remove();\n                const fig = new stackedHistogramChart(el.current,props.layout,props.margins,settings);\n\n                fig.draw();\n\n                fig.onHover(callback,\".rect\")\n                fig.onClick((d,i,n)=>alert(`clicked ${d.data.id}`))\n                // fig.addToolTip('.rect-layer .rect',(d,i,n)=>\"Whoop here it is!\")\n\n                select(el.current).select(\".axes-layer\").select(\"#x-axis\").remove();\n                setHistogram(fig);\n            \n        },[props.data]);\n\n    const rand_id = `b${Math.random().toString(36).substring(4)}`\n    useEffect(()=>{\n        if(histogram!==null){\n            histogram.update()\n        }\n    },[props.chartGeom,props.data])\n    return(\n        <svg className=\"chart\" id= {rand_id}\n             ref={el}\n             height={props.chartGeom.height}\n             width={props.chartGeom.width}\n        />);\n\n};\n\nexport default StackedHistogram;\n","import React, {useEffect,useRef,useState} from 'react';\nimport {TransmissionLayout, RectangularLayout, Tree} from '../lib/figtree.js/index.js';\nimport { FigTree, CircleBauble } from '../lib/figtree.js/index.js';\nimport {select} from 'd3-selection';\nimport {scaleTime,scaleLinear} from \"d3-scale\";\nimport {extent} from \"d3-array\";\n\nfunction PhyloChart(props){\n    const [figtree,setFigtree]=useState(null);\n\n    const el = useRef();\n        useEffect(()=>{ // make it the first time\n                const dateRangeScale = scaleTime().domain(extent(props.dateRange)).range([0,1]); // converts date to final domain (horizontal scale)\n                const treeRange = props.treeDateRange.map(d=>dateRangeScale(d)); // horizontal range of tree within date range converted to [0,1]\n                const rootToTipScale = scaleLinear().domain(extent([0,...props.phylogeny.rootToTipLengths()])).range(treeRange) // converts root to tip distance to horizontal range of tree on [0,1]\n                const layout = new props.layout(props.phylogeny,{horizontalScale:rootToTipScale});\n\n                const fig = new FigTree(el.current,layout,props.margins, { hoverBorder: 4, backgroundBorder:2,\n                    baubles: [\n                        new CircleBauble(),\n                    ],\n                    tranitionDuration:0\n                });\n                fig.draw();\n                fig.hilightInternalNodes();\n                fig.hilightExternalNodes();\n                fig.hilightBranches();\n                fig.onClickNode(d=>console.log(d))\n                select(el.current).select(\".axes-layer\").remove();\n                setFigtree(fig);\n\n            },[]);\n            useEffect(()=>{\n                if(figtree!==null){\n                    figtree.update()\n                }\n            },[props.chartGeom,props.phylogeny])\n\n    const rand_id = `b${Math.random().toString(36).substring(4)}`\n\n    // useEffect(()=>{\n    //     if(figtree!==null){\n    //         figtree.update()\n    //     }\n    // },[props.chartGeom,props.phylogeny])\n\n    return(\n        <svg className=\"chart\" id={\"phylogeny\"}\n             ref={el}\n             height={props.chartGeom.height}\n             width={props.chartGeom.width}\n        />);\n\n};\n\n\n\nexport default PhyloChart;","import {timeWeek} from 'd3-time';\nimport {min,max,sum} from 'd3-array';\n\nexport class Outbreak{\n\n    constructor(id,location,cases=[]){\n        this.location=location;\n        this.cases=cases;\n        this.id=id;\n        this.children=[];\n    }\n\n    addCase(Case){\n        this.cases = [...this.cases,Case];\n    }\n\n    get timeCourse(){\n        const timePoints= this.timePoints;\n        //Weeks are hardcoded in.\n        const tc = new Map(timePoints.map(t=>[t,{time:new Date(t), cases:this.cases.filter(c=>timeWeek(c.symptomOnset)-t===0).length}]))\n        if(this.children.length===0){\n            tc.forEach(d=>d.totalDescendents=d.cases)\n        }else{\n            const childrenTimeCourse = this.children.map(child=>child.timeCourse);\n            // now get children timepoints that were misssed in this level\n\n            for(const child of childrenTimeCourse){\n                for(const k of child.keys()){\n                    if(timePoints.indexOf(k) === -1){\n                        timePoints.push(k);\n                        tc.set(k,{time:new Date(k),cases:0})\n                    }\n                }\n            }\n\n            for(const timePoint of timePoints){\n                const childrenCourses = childrenTimeCourse.map(child=>child.has(timePoint)?child.get(timePoint):{cases:0,totalDescendents:0})\n                //https://stackoverflow.com/questions/10865025/merge-flatten-an-array-of-arrays\n\n                const childrenCases = sum(childrenCourses,d=>d.totalDescendents)\n                const tp = tc.get(timePoint)\n                tc.set(timePoint,{...tp,...{totalDescendents:tp.cases+childrenCases}});\n            }\n\n        }\n        return tc;\n    }\n\n    addChild(child){\n        if(child instanceof Outbreak){\n            this.children.push(child)\n            child.parent=this;\n        }else if(child instanceof Array){\n            child.forEach(k=>this.addChild(k))\n        }\n    }\n\n    get timePoints(){\n\n        const firstTimePoints =[min(this.cases,d=>d.symptomOnset)];\n        const lastTimePoints = [max(this.cases,d=>d.symptomOnset)]\n\n        if(this.children.length>0){\n            for(const child of this.children){\n                const childTP = child.timePoints;\n                firstTimePoints.push(min(childTP))\n                lastTimePoints.push(max(childTP))\n            }\n        }\n// const finalWeek = timeWeek(max(lastTimePoin\n\n        const tp= timeWeek.range(timeWeek.offset(min(firstTimePoints),-1),timeWeek.offset(max(lastTimePoints),2)).map(d=>d.getTime())\n\n        return tp;\n    }\n\n    /**\n     * A generator function that returns the nodes in a pre-order traversal.\n     *\n     * @returns {IterableIterator<IterableIterator<*|*>>}\n     */\n    *preorder() {\n        const traverse = function *(node) {\n            yield node;\n            if (node.children) {\n                for (const child of node.children) {\n                    yield* traverse(child);\n                }\n            }\n        };\n\n        yield* traverse(this);\n    }\n\n    /**\n     * A generator function that returns the nodes in a post-order traversal\n     *\n     * @returns {IterableIterator<IterableIterator<*|*>>}\n     */\n    *postorder() {\n        const traverse = function *(node) {\n            if (node.children) {\n                for (const child of node.children) {\n                    yield* traverse(child);\n                }\n            }\n            yield node;\n        };\n\n        yield* traverse(this);\n    }\n}","import {Outbreak} from \"../outbreak/Outbreak.js\";\nimport {max, sum,min,extent} from 'd3-array';\nimport {timeWeek} from 'd3-time';\nimport {scaleLinear} from 'd3-scale';\nimport { d3PlotLayout } from \"./d3PlotLayout.js\";\n\n/**\n * The Fishplot layout\n * This takes an epidemic object and calculates the total number of cases at each time point and the relative contribution\n * of each outbreak. It returns a points arrary with with a y0 and y1 for each x for each outbreak in the epidemic.\n */\n\n\nexport class fishLayout extends d3PlotLayout{  \n  static DEFAULT_SETTINGS() {\n    return {\n        horizontalRange:null,\n        horizontalTicks:null,\n        horizontalScale:scaleLinear,\n        percent:false\n    }\n}\n  /**\n   * The constructor \n   * @param {Epidemic} And epidemic object Epidemic \n   * @param {*} settings \n   */\n    constructor (Epidemic,settings){\n      super();\n      this.settings = {...fishLayout.DEFAULT_SETTINGS(), ...settings};\n      this.backgroundOutbreak=new Outbreak(\"background\",null,[]);\n      this.backgroundOutbreak.addChild(Epidemic.rootOutbreak)\n      this.gapMap = new Map();\n      this.setGapMap();\n      this.points = [];\n      // Defualt ranges\n      this._horizontalRange = [0.0, 1.0];\n      this._verticalRange = [1.0, 0];\n      this._horizontalTicks= this.settings.horizontalScale()\n      .domain(this._horizontalRange).ticks(5)\n     }\n    // This adds a parent entry to each outbreak that has one.\n    \n\n    /**\n     * creates a map that has each outbreak as a key. with values that are maps with timepoints as the key\n     * And values that are arrays of [space on top, ... space between child 1 and child 2, space between child2& 3 ..., space between childLast and bottom]\n     */\n    setGapMap(){\n      // get every time point\n      const totalCourse = this.backgroundOutbreak.timeCourse;\n      for(const outbreak of [...this.backgroundOutbreak.preorder()]){\n        const timeGap = new Map();\n        const timeCourse = outbreak.timeCourse;\n       for(const time of outbreak.timePoints){\n          const timePoint = timeCourse.has(time)? timeCourse.get(time): {time:new Date(time), cases:0,totalDescendents:0}\n          // The % of total cases at this time point that can be attributed the this outbreak and it's dependents.\n         timePoint.percent = totalCourse.get(time)[\"totalDescendents\"]!==0?timePoint.totalDescendents/totalCourse.get(time)[\"totalDescendents\"]:0;\n         // what percent of this outbreak's space is attributed to it's children in raw total percent\n         const childrenSpace = timePoint.totalDescendents!==0? ((timePoint.totalDescendents-timePoint.cases)/timePoint.totalDescendents)*timePoint.percent:0;\n         \n         let activeChildren = 0;\n         if( childrenSpace>0){\n            //how many children have cases at this time\n           activeChildren =  outbreak.children\n                                .filter(chap=>chap.timeCourse.has(time) && chap.timeCourse.get(time).totalDescendents>0).length\n         }\n         \n         // how much space is there to divy up between the top, bottom and between children\n        const innerSpace =(timePoint.percent-childrenSpace);///(activeChildren+1);\n         // we want most of the space to be on top so the children curves aren't pulled up buy the parent\n         // ~75% of gap on top. ~20% at bottom 5% between children\n         // an array of 0.05/# of children\n        //  const kidGaps = Array(max([(activeChildren-1),0])).fill(0.05/(activeChildren-1));\n        //  the line above was causing issues I'm just doing how many children.\n        \n        //  const innerSpaceArray = [0.85,...kidGaps,(1-0.85-sum(kidGaps))].map(d=>d*innerSpace);\n         const numberOfKidGaps = outbreak.children?outbreak.children.length:0;\n         const kidGaps = Array(max([(numberOfKidGaps-1),0])).fill(0.05/(numberOfKidGaps-1));\n        const innerSpaceArray = [0.85,...kidGaps,(1-0.85-0.1)].map(d=>d*innerSpace);\n         // inner space Arrary is [space on top, ... space between child 1 and child 2, space between child2& 3 ..., space between childLast and bottom]\n          timeGap.set(time,innerSpaceArray);\n       }\n      this.gapMap.set(outbreak,timeGap);   \n      }\n      \n    }\n    /** Sets the points the child outbreak of the provided outbreak. This is called \n     * recursively.\n    */\n\n    setPoints(outbreak = this.backgroundOutbreak){\n      // Get all the time points of the data\n      const totalCourse = this.backgroundOutbreak.timeCourse;\n      // Get the gapMap of the of the outbreak. \n      const gapMap = this.gapMap.get(outbreak);\n      // will be updated overtime to account for the space from the top outbreak\n      // that has been taken up at each point.\n      let i=0;\n      const spaceFilled= new Map(outbreak.timePoints.map(t=>[t,gapMap.get(t)[i]]));\n       // starts as just the top gaps.\n      // fillPoints \n      for(const childOutbreak of outbreak.children){\n         let points = [];\n         const timeCourse = childOutbreak.timeCourse;\n        for(const time of childOutbreak.timePoints){\n          const timePoint = timeCourse.get(time);\n          //Each time point has the total descendents of that outbreak at this time and the cases in this particular outbreak.\n          timePoint.percent = totalCourse.get(time)[\"totalDescendents\"]>0?timePoint.totalDescendents/totalCourse.get(time)[\"totalDescendents\"]: 0;\n          const parentTop =getStartingDistance.call(this,childOutbreak,time);\n          const point = {time:time,y1:parentTop-spaceFilled.get(time),\n                         y0:parentTop-spaceFilled.get(time)-timePoint.percent,\n                         data:childOutbreak,\n                         total:totalCourse.get(time).totalDescendents}\n          if(this.settings.percent){\n            point.total=1;\n          }\n          this.addAnnotations({outbreakId:childOutbreak.id,location:childOutbreak.location})\n          points.push(point) \n          spaceFilled.set(time,spaceFilled.get(time)+timePoint.percent+gapMap.get(time)[i+1]);\n        }\n        // clean up final point.\n        //\n        if(points.length>0){ // if there is no time data for this then we can't place it.\n        const first0T = max(points.filter(p=>p.y1===p.y0),d=>d.time);\n        const first0 = points.filter(p=>p.time===first0T)[0];\n        const lastTP= max(points.filter(p=>p.y1!==p.y0),d=>d.time);\n        const lastT = points.filter(p=>p.time===lastTP)[0];\n\n        points = points.filter(p=>p.time<first0.time);\n        \n        const smoothingPoint = {time : first0.time, \n                                y1:(lastT.y1+lastT.y0)/2, \n                                y0:(lastT.y1+lastT.y0)/2,\n                                data:lastT.data,\n                                total:first0.total};\n                                \n        points.push(smoothingPoint);\n        \n        //add smoothStart\n        const firstTP = min(points,d=>d.time);\n        \n        const firstT = points.filter(p=>p.time===firstTP)[0];\n        \n        const newFirstTP = timeWeek.offset(firstTP,-1).getTime();\n        \n        const totalAtTheTime = totalCourse.has(newFirstTP)&&totalCourse.get(newFirstTP)[\"totalDescendents\"]>0?totalCourse.get(newFirstTP)[\"totalDescendents\"]:0\n        \n        const easyStart =  {time : newFirstTP, \n                                y1:(firstT.y1+firstT.y0)/2, \n                                y0:(firstT.y1+firstT.y0)/2,\n                                data:firstT.data,\n                                total:totalAtTheTime};\n        \n        \n        points.unshift(easyStart);\n        }else{\n          console.log(`no time points found for outbreak ${childOutbreak.id} The samples may be missing data`)\n        }\n        points.sort((a,b)=>a.time-b.time);\n        this.points.push(points);\n        i+=1;\n        this.setPoints(childOutbreak);\n      }\n      \n    }\n\n    layout(input_points){\n      this.points = [];\n      this.setPoints();\n      input_points.push(...this.points);\n\n      if(!this.settings.horizontalRange){\n        this._horizontalRange = extent(this.points.reduce((acc,curr)=>[...acc,...curr],[]),k=>new Date(k.time));\n      }else{\n        this._horizontalRange=this.settings.horizontalRange;\n    }\n    \n    if(!this.settings.horizontalTicks){\n        this._horizontalTicks= this.settings.horizontalScale()\n            .domain(this._horizontalRange).ticks(5)\n    }else{\n        this._horizontalTicks=this.settings.horizontalTicks;\n    }\n      this._verticalRange = extent(this.points.reduce((acc,curr)=>[...acc,...curr],[]),k=>k.total*k.y1)\n    }\n\n    update() {\n      this.updateCallback();\n  }\n\n    get horizontalRange() {\n      return this._horizontalRange;\n    }\n\n  get verticalRange() {\n      return this._verticalRange;\n    }\n    get horizontalAxisTicks(){\n      return this._horizontalTicks;\n  }\n  }\n\n  \n  function getStartingDistance(outbreak,t){\n    // points is an array of arrays each inner array is an oubreak we want the one with the parent.\n    const parentPoints = this.points.find(d=>d[0].data===outbreak.parent);\n    if(typeof parentPoints==='undefined'){\n      // The parent outbreak is the background outbreak\n      return 1;\n    }\n    const atThisTime = parentPoints.find(p=>p.time===t)\n    return(atThisTime.y1);\n  }","import {axisLeft, axisBottom} from \"d3-axis\";\nimport {select,selectAll} from \"d3-selection\";\nimport {scaleLinear,scaleTime} from \"d3-scale\";\nimport {easeLinear} from \"d3-ease\";\nimport {max,min} from \"d3-array\";\nimport {area,curveBasis} from \"d3-shape\";\nimport {timeWeek} from \"d3-time\"\nimport {transition} from \"d3-transition\"\nimport { d3Plot } from \"./d3Plot\";\n\nexport class areaPlot extends d3Plot{\n  static DEFAULT_SETTINGS() {\n        return {\n      hoverBorder: 2,\n      tranitionDuration:0,\n      curve:curveBasis,\n        }\n      }\n      /**\n       * The constructor\n       * @param {*} svg \n       * @param {*} layout \n       * @param {*} margins top,bottom,left,right\n       * @param {*} settings \n       */\n    constructor(svg, layout, margins, settings = {}){\n        super()\n      this.layout = layout;\n      this.margins = margins;\n\n      // merge the default settings with the supplied settings\n      this.settings = {...d3Plot.DEFAULT_SETTINGS(),...areaPlot.DEFAULT_SETTINGS(), ...settings};\n      this.svg=svg;\n      }\n    \n        addDataLayers(){\n            this.svgSelection.append(\"g\").attr(\"class\", \"area-layer\");\n        }\n\n        draw(){\n          let width,height;\n        if(Object.keys(this.settings).indexOf(\"width\")>-1){\n            width =this.settings.width;\n        }else{\n            width = this.svg.getBoundingClientRect().width;\n        }\n        if(Object.keys(this.settings).indexOf(\"height\")>-1){\n            height =this.settings.height;\n        }else{\n            height = this.svg.getBoundingClientRect().height;\n        }\n \n        //remove the tree if it is there already\n        select(this.svg).select(\"g\").remove();\n \n        // add a group which will contain the new plot\n        select(this.svg).append(\"g\")\n            .attr(\"transform\",`translate(${this.margins.left},${this.margins.top})`);\n \n         //to selecting every time\n         this.svgSelection = select(this.svg).select(\"g\");\n\n         this.svgSelection.append(\"g\").attr(\"class\", \"axes-layer\");\n\n         this.addDataLayers();\n         \n         // create the scales\n         const xScale = this.settings.xScaleType()\n         .domain(this.layout.horizontalRange)\n         .range([this.margins.left, width - this.margins.right-this.margins.left]);\n         \n         //height is total \n         const yScale = this.settings.yScaleType()\n             .domain(this.layout.verticalRange)\n             .range([height -this.margins.bottom-this.margins.top,this.margins.top]);\n \n         this.scales = {x:xScale, y:yScale, width, height};\n         this.addAxis();\n \n         // Called whenever the layout changes...\n           this.layout.updateCallback = () => {\n                 this.update();\n             }\n\n             this.points = []; // rest to so will be filled\n             this.layout.layout(this.points);\n     \n             this.update();\n        }\n        update(){\n        // get new positions\n\n        // svg may have changed sizes\n        let width,height;\n        if(Object.keys(this.settings).indexOf(\"width\")>-1){\n            width =this.settings.width;\n        }else{\n            width = this.svg.getBoundingClientRect().width;\n        }\n        if(Object.keys(this.settings).indexOf(\"height\")>-1){\n            height =this.settings.height;\n        }else{\n            height = this.svg.getBoundingClientRect().height;\n        }\n        // update the scales' domains\n        this.scales.x.domain(this.layout.horizontalRange).range([this.margins.left, width - this.margins.right-this.margins.left]);\n        this.scales.y.domain(this.layout.verticalRange).range([height -this.margins.bottom-this.margins.top,this.margins.top]);\n        this.scales.width=width;\n        this.scales.height=height;\n\n        // updateAxis.call(this);\n\n      updateAreas.call(this);\n      this.updateAxis();\n      // this.updateAxisBars();\n\n    }\n/**\n * Add a hover callback\n * @param {*} action  - object which has 2 functions enter and exit each takes 3 arguments d,i,n d is data n[i] is `this`\n * @param {*} selection  - what to select defaults to .rect class\n */\n  // onHover(action,selection=null){\n  //     const selected = this.svgSelection.selectAll(`${selection ? selection : \"path\"}`);\n  //     selected.on(\"mouseover\", (d,i,n) => {\n  //         action.enter(d,i,n);\n  //     });\n  //     selected.on(\"mouseout\", (d,i,n) => {\n  //         action.exit(d,i,n);\n  //     });\n  // }\n//   onClick(action,selection=null){\n//     const selected = this.svgSelection.selectAll(`${selection ? selection : \"path\"}`);\n//     selected.on(\"click\", (d,i,n) => {\n//         action(d,i,n);\n//     });\n//   }\n}\n\nfunction updateAreas(){\n    const areaMaker = area()\n    .x(d => this.scales.x(new Date(d.time)))\n    .y0(d=> this.scales.y(d.y0*d.total))\n    .y1(d => this.scales.y(d.y1*d.total))\n    .curve(curveBasis)\n  // DATA JOIN\n    // Join new data with old elements, if any.\n    const areas = this.svgSelection.select(\".area-layer\")\n        .selectAll(\"path\")\n        .data(this.points,d=>d[0].data.id);\n    // ENTER\n    // Create new elements as needed.\n       const newAreas=areas.enter()\n        .append(\"path\")\n        .attr(\"class\", (d) => [\"fishArea\",...this.getAnnotations(d[0].data)].join(\" \")) // add attribute classes here\n        .attr(\"stroke-width\",4)\n        .attr(\"stroke\",d=>\"black\")\n        .attr(\"d\", d => areaMaker(d))\n       // update the existing elements\n    areas\n    .transition()\n    .duration(this.settings.transitionDuration)\n    .attr(\"d\", d => areaMaker(d));\n     // EXIT\n    // Remove old elements as needed.\n    areas.exit().remove();\n};\n\nfunction updateAxis(){\n        // update axis\n    \n    this.svgSelection.select(\"#y-axis\")\n    .attr(\"transform\", `translate(${this.margins.left.height },0)`)\n    .call(axisLeft(this.scales.y).ticks(5))\n      .transition()\n      .duration(this.settings.transitionDuration)\n      .ease(easeLinear)\n  }\n  ","import {Outbreak} from './Outbreak.js';\n\nexport class Epidemic{\n constructor(indexCase,graph,edgeConditionFactory = e=>true){\n   this.outbreaks=[];\n   this.outbreakMap= new Map();\n   this.graph = graph;\n   this.edgeCondition =edgeConditionFactory(this.graph);\n   this.setOutbreaks(indexCase);\n\n }\n  setOutbreaks(indexCase){\n    // If the location of the index is unknow set to the most common location of the childrent;\n    const firstOutbreak = new Outbreak(`${indexCase.location}-${indexCase.id}`,indexCase.location,[indexCase]);\n    \n    this.rootOutbreak = firstOutbreak;\n    firstOutbreak.indexCase=indexCase;\n    this.outbreakMap.set(indexCase,firstOutbreak);\n    this.outbreaks.push(firstOutbreak);\n    const children = this.graph.getOutgoingEdges(indexCase).filter(this.edgeCondition)\n    .map(e => ({edge:e,Case:e.target}))\n    \n    for(const child of children){\n      this.outbreakTraversal(child)\n    }    \n  }\n  outbreakTraversal(CaseEdge){\n   const Case = CaseEdge.Case;\n   const edge = CaseEdge.edge;\n   const parent =   edge.source;\n   const parentOutbreak = this.outbreakMap.get(parent);\n    // Removes possiblity of circular traversal and certain death\n    if(this.outbreakMap.has(Case)){\n      return\n    }\n   let currentOutbreak;\n  if(Case.location === parent.location){\n    // add case to parent outbreak\n    parentOutbreak.addCase(Case);\n    Case.outbreakId=parentOutbreak.id;\n    this.outbreakMap.set(Case,parentOutbreak);\n\n    currentOutbreak = parentOutbreak;\n    \n  }else{\n    const startAnotherOutbreak = new Outbreak(`${Case.location}-${Case.id}`,Case.location,[Case]);\n    Case.outbreakId=startAnotherOutbreak.id;\n    startAnotherOutbreak.indexCase=Case;\n    parentOutbreak.addChild(startAnotherOutbreak);\n    this.outbreakMap.set(Case,startAnotherOutbreak);\n    this.outbreaks.push(startAnotherOutbreak);\n    currentOutbreak = startAnotherOutbreak;\n  }\n   const children = this.graph.getOutgoingEdges(Case).filter(e=>(this.edgeCondition))\n     .map(e => ({edge:e,Case:e.target}))\n    .filter(c=>!this.outbreakMap.has(c.Case));\n    //avoids circlular loop when edge condition is not sufficient.\n  for(const child of children){\n    this.outbreakTraversal(child)\n  }\n}\nget Cases(){\n  return this.outbreaks.reduce((acc,curr)=>[...acc,...curr.cases],[]);\n}\n\n\n  \n  \n}","import React, {useRef,useEffect,useState} from 'react';\nimport {select,selectAll} from 'd3-selection';\nimport {fishLayout} from \"../lib/charts/fishplotLayout\"\nimport {areaPlot} from \"../lib/charts/areaPlot\";\nimport {timeWeek} from \"d3-time\";\nimport {scaleTime} from \"d3-scale\";\nimport {extent} from 'd3-array';\nimport {event,timeFormat,max} from 'd3';\nimport {epidemic, Epidemic} from \"../lib/outbreak/Epidemic\";\nimport { Graph } from '../lib/figtree.js';\nconst formatTime = timeFormat(\"%B %d, %Y\");\nconst getAllCases=(o,a)=>{\n    a.push(...o.cases)\n    for(const child of o.children){\n        getAllCases(child,a);\n    } \n    ;\n}\n\nconst mouseEnter = (d, i, n)=>{\n    const outbreak = d[0].data;\n    const allAreas = selectAll(n);\n    const notSelected = !select(n[i]).attr(\"class\").includes(\"selected\");\n    if(notSelected){\n    allAreas.filter((d2,i2,n2)=>n2[i2]!==n[i]).classed(\"not-hovered\", true);\n    select(n[i]).classed(\"hovered\", true);\n    }\n  \n\n\n    let tooltip = document.getElementById(\"tooltip\");\n    const exportEvents = d[0].data.children\n                    .map(c=>`${c.location} - ${formatTime(c.cases[0].symptomOnset)}`)\n                    .join(\"<br/>\");\n\n    // put text to display here!\n    tooltip.innerHTML = `Local circulation\n                        <br/>\n                        Location: ${d[0].data.location}\n                        <br/>\n                        Cases: ${d[0].data.cases.length}\n                        ${(d[0].data.parent.location!==null?\n                             `<br/>\n                             Source: ${d[0].data.parent.location}`:\"\")}\n                        ${d[0].data.children.length>0?`<br/>Export Events<br/>${exportEvents}`:\"\"}\n                        `\n\n                        ;\n\n    tooltip.style.display = \"block\";\n    tooltip.style.left = event.pageX + (event.pageX > 800? -300 : + 10) + \"px\";\n    tooltip.style.top = event.pageY + 10 + \"px\";\n    tooltip.style.visibility =\"visible\";\n};\nconst mouseExit = (d,i,n) => {\n    const notSelected = !select(n[i]).attr(\"class\").includes(\"selected\");\n    if(notSelected){\n        selectAll(n).classed(\"not-hovered\", false);\n        select(n[i]).classed(\"hovered\", false);\n    }\n\n        const tooltip = document.getElementById(\"tooltip\");\n        tooltip.style.visibility = \"hidden\";\n        // selectAll(\".rect\").classed(\"hidden\",false)\n        // selectAll(\".node\").classed(\"hidden\",false)\n        // selectAll(\".node-background\").classed(\"hidden\",false)\n        // selectAll(\".branch\").classed(\"hidden\",false)\n    };\n\nconst callback = {enter:mouseEnter,exit:mouseExit};\n\nconst clickHover=(d,i,n)=>{\n    const outbreak = d[0].data;\n    const allAreas = selectAll(n);\n    const shouldSelect = !select(n[i]).attr(\"class\").includes(\"selected\");\n    allAreas.filter((d2,i2,n2)=>n2[i2]!==n[i]).classed(\"not-selected\", shouldSelect);\n    select(n[i]).classed(\"selected\", shouldSelect);\n\n    selectAll(\".rect\").classed(\"hidden\",shouldSelect)\n    selectAll(\".node\").classed(\"hidden\",shouldSelect)\n    selectAll(\".node-background\").classed(\"hidden\",shouldSelect)\n    selectAll(\".branch\").classed(\"hidden\",shouldSelect)\n    const bringBack = [];\n    getAllCases(outbreak,bringBack)\n    // console.log(bringBack)\n    // bringBack.forEach(c=>selectAll(`.node .id-${c.id}`).classed(\"hidden\",false))\n    if(shouldSelect){\n    bringBack.forEach(c=>selectAll(`.id-${c.id}`).classed(\"hidden\",!shouldSelect))\n    bringBack.forEach(c=>selectAll(`.source-${c.id}`).classed(\"hidden\",!shouldSelect))\n    bringBack.forEach(c=>selectAll(`.target-${c.id}`).classed(\"hidden\",!shouldSelect))\n    bringBack.forEach(c=>selectAll(`.tip-${c.id}`).classed(\"hidden\",!shouldSelect))\n\n    }\n}\n\nfunction AreaPlot(props){\n    const [plot,setPlot]=useState(null);\n    const areaClick=(d,i,n)=>{\n        const outbreak = d[0].data;\n        const selectedEpidemic = new Epidemic(outbreak.indexCase,props.epidemic.graph,mostProbableTransphyloEdgeCondition)\n        // select edges in graph \n        const newCases = selectedEpidemic.Cases;\n        const goodEdges = [];\n        for(const Case of newCases){\n            // incoming\n            const incoming = selectedEpidemic.graph.getIncomingEdges(Case);\n            incoming.forEach(e=>newCases.indexOf(e.source)>-1&&goodEdges.push({source:e.source.id,target:e.target.id,metaData:e.metaData}));\n            // outgoing\n            const outgoing = selectedEpidemic.graph.getOutgoingEdges(Case);\n            outgoing.forEach(e=>newCases.indexOf(e.target)>-1&&goodEdges.push({source:e.source.id,target:e.target.id,metaData:e.metaData}));\n        }\n        selectedEpidemic.graph = new Graph(selectedEpidemic.Cases,goodEdges)\n        props.selectArea(selectedEpidemic)\n    }\n        const el = useRef();\n        useEffect(()=>{\n            // const layout = new fishLayout(props.epidemic,layoutSettings);\n            const fig = new areaPlot(el.current,props.layout,props.margins, { hoverBorder: 4, backgroundBorder:2,tranitionDuration:0});\n            fig.draw();\n            \n            fig.onHover(callback,\".fishArea\")\n            fig.onClick(clickHover,\".fishArea\")\n            setPlot(fig);\n            },[]);\n\n        const rand_id = `b${Math.random().toString(36).substring(4)}`\n\n        useEffect(()=>{\n            if(plot!==null){\n                plot.update()\n            }\n        },[props.chartGeom,props.epidemic])\n\n         return(\n                <svg className=\"chart\" id={rand_id}\n                ref={el}\n                height={props.chartGeom.height}\n                width={props.chartGeom.width}\n            />);\n         \n};\n\n\n// Set the epidemic data\nfunction mostProbableTransphyloEdgeCondition(graph){\n    const actualFilterFunction = (edge)=>{\n        const target = edge.target;\n        // get incoming edges\n        const incomingEdges = graph.getIncomingEdges(target);\n        const maxTransphyloProb = max(incomingEdges.filter(e=>e.metaData.dataSource===\"transphylo\"), e =>e.metaData.support);\n        return (edge === incomingEdges.find(e=> e.metaData.dataSource===\"transphylo\" && e.metaData.support===maxTransphyloProb))\n    }\n    return actualFilterFunction\n}\nexport default AreaPlot;","import React, {useState,useRef,useEffect,useCallback} from 'react';\nimport ObjectChart from \"./ObjectChart\";\nimport {ArcLayout,CircleBauble}  from '../lib/figtree.js/index.js';\nimport { FigTree }  from '../lib/figtree.js/index.js';\nimport {scaleTime,scaleLinear} from \"d3-scale\";\nimport {select,selectAll} from 'd3-selection';\nimport {extent} from 'd3-array';\nimport {event,timeFormat,raise} from 'd3';\nimport { userInfo } from 'os';\nconst formatTime = timeFormat(\"%B %d, %Y\");\n\nconst branchMouseEnter = (d, i, n,fig)=>{\n    select(n[i]).classed(\"hovered\", true);\n\n    let tooltip = document.getElementById(\"tooltip\");\n    // put text to display here!\n    tooltip.innerHTML = `Source: ${d.data.source.id}\n                        <br/>\n                        Target: ${d.data.target.id}\n                        <br/>\n                        Data source: ${d.data.metaData.dataSource}\n                        <br/>\n                        Support:${d.data.metaData.support}`;\n\n    tooltip.style.display = \"block\";\n    tooltip.style.left =event.pageX + 10 + \"px\";\n    tooltip.style.top = event.pageY + 10 + \"px\";\n    tooltip.style.visibility =\"visible\";\n    // mimics highlight nodes in figtree\n        for(const dataNode of [d.data.source,d.data.target]){\n            const nodeGroup =  fig.svgSelection.select(`.node.id-${dataNode.id}`)\n            const nodeShape = nodeGroup.select(\".node-shape\");\n            nodeGroup.raise(); //da roof - bring to the top of the g groups.\n            fig.settings.baubles.forEach((bauble) => {\n                if (bauble.vertexFilter(nodeShape)) {\n                    bauble.updateShapes(nodeShape, fig.settings.hoverBorder);\n                }\n            });\n            nodeShape.classed(\"hovered\", true);\n        }\n};\nconst branchMouseExit = (d,i,n,fig) => {\n        select(n[i]).classed(\"hovered\", false);\n\n        const tooltip = document.getElementById(\"tooltip\");\n        tooltip.style.visibility = \"hidden\";\n\n            // mimics highlight nodes in figtree\n        for(const terminal of [d.data.source,d.data.target]){\n            const node =  fig.svgSelection.select(`.node.id-${terminal.id}`).select(\".node-shape\");\n            fig.settings.baubles.forEach((bauble) => {\n                if (bauble.vertexFilter(node)) {\n                    bauble.updateShapes(node, 0);\n                }\n            });\n            node.classed(\"hovered\", false);\n        }\n    };\nconst branchCallback = {enter:branchMouseEnter,exit:branchMouseExit};\n\nconst nodeMouseEnter = (d, i, n,fig)=>{\n\n    // n[i] is this - the circle that is the node-shape.\n\n\n    let tooltip = document.getElementById(\"tooltip\");\n    // put text to display here!\n    tooltip.innerHTML = `Case Id: ${d.node.id}\n                        <br/>\n                        Location: ${d.node.location}\n                        <br/>\n                        Symptom onset: ${formatTime(d.node.symptomOnset)}`;\n\n    tooltip.style.display = \"block\";\n    tooltip.style.left =event.pageX + 10 + \"px\";\n    tooltip.style.top = event.pageY + 10 + \"px\";\n    tooltip.style.visibility =\"visible\";\n\n    // potential sources\n    //Branches \n    const incomingBranches =  fig.svgSelection.selectAll(`.branch.target-${d.node.id}`)\n    incomingBranches.raise();\n    incomingBranches.select(\".branch-path\")\n        .classed(\"hovered\",true)\n    \n    const outGoingBranches =  fig.svgSelection.selectAll(`.branch.source-${d.node.id}`)\n    outGoingBranches.raise();\n    outGoingBranches.select(\".branch-path\")\n        .classed(\"hovered\",true)\n        \n        \n    \n\n    const sourceNodes = fig.layout.graph.getIncomingEdges(d.node).map(e=>e.source);\n    for(const dataNode of [...sourceNodes]){\n       fig.highlightNode(dataNode.id,\"source\")\n    }\n\n    // Targets\n    const targetNodes = fig.layout.graph.getOutgoingEdges(d.node).map(e=>e.target);\n    for(const dataNode of [...targetNodes]){\n        fig.highlightNode(dataNode.id,\"transmission\")\n     }\n\n    const thisNode = select(n[i]).classed(\"hovered\",true);\n    fig.settings.baubles.forEach((bauble) => {\n        if (bauble.vertexFilter(thisNode)) {\n            bauble.updateShapes(thisNode, fig.settings.hoverBorder);\n        }\n    });\n    select(n[i].parentNode).raise();\n    //raise the g group the node is in.\n};\nconst nodeMouseExit = (d,i,n,fig) => {\n    const thisNode = select(n[i]).classed(\"hovered\",false);\n    fig.settings.baubles.forEach((bauble) => {\n        if (bauble.vertexFilter(thisNode)) {\n            bauble.updateShapes(thisNode, 0);\n        }\n    });\n    const tooltip = document.getElementById(\"tooltip\");\n    tooltip.style.visibility = \"hidden\";\n\n    fig.svgSelection.selectAll(`.branch.target-${d.node.id}`).select(\".branch-path\")\n       .classed(\"hovered\",false)\n    fig.svgSelection.selectAll(`.branch.source-${d.node.id}`).select(\".branch-path\")\n       .classed(\"hovered\",false)\n\n    const sourceNodes = fig.layout.graph.getIncomingEdges(d.node).map(e=>e.source);\n    // sourceNodes.classed(\"attr\",'hovered')\n    // mimics highlight nodes in figtree\n    for(const source of sourceNodes){\n        const node =  fig.svgSelection.select(`.node.id-${source.id}`).select(\".node-shape\");\n        if(node.attr(\"class\").includes(\"selected\")){\n           fig.unHighlightNode(source.id,\"\")  // leave source for selection\n\n        }else{\n            fig.unHighlightNode(source.id,\"source\")  // leave source for selection\n        }        \n    }\n\n        // Targets\n        const targetNodes = fig.layout.graph.getOutgoingEdges(d.node).map(e=>e.target);\n        for(const dataNode of [...targetNodes]){\n            const node =  fig.svgSelection.select(`.node.id-${dataNode.id}`).select(\".node-shape\");\n            if(node.attr(\"class\").includes(\"selected\")){\n                fig.unHighlightNode(dataNode.id,\"\")  // leave transmission for selection\n     \n             }else{\n                 fig.unHighlightNode(dataNode.id,\"transmission\")  // leave source for selection\n             }        \n         }\n\n    };\nconst nodeCallback = {enter:nodeMouseEnter,exit:nodeMouseExit};\n    \n\n\nfunction ArcTransmission(props){\n    // Selection call back\n    const nodeClick = (d,i,n,fig) =>{\n        // remove all selections\n        // is it already selected?\n        const shouldSelect = !select(n[i]).attr(\"class\").includes(\"selected\");\n        if(shouldSelect){\n            // props.selectedCases is defined on first render as an empty array. This is why this append doesn't work\n            // insead it replaces. \n            props.setSelectedCases([...props.selectedCases,d.node])\n        }else{\n            props.setSelectedCases(props.selectedCases.filter(d=>d!==d.node))\n        }\n        // remove all other selections\n        selectAll(\".selected\").classed(\"selected source transmission\",false)\n        \n\n        select(n[i]).classed(\"selected\", shouldSelect);\n        selectAll(`.id-${d.node.id}`).classed(\"selected\", shouldSelect);\n        //to get other trees\n        selectAll(`.id-${d.node.id}`).select(\".node-shape\").classed(\"selected\", shouldSelect);\n        selectAll(`.id-${d.node.id}`).select(\".branch-path\").classed(\"selected\", shouldSelect);\n\n        // potential sources\n        // maybe select all to grab branches in the tree.\n        fig.svgSelection.selectAll(`.branch.target-${d.node.id}`).select(\".branch-path\")\n            .classed(\"selected\",shouldSelect)\n        \n        fig.svgSelection.selectAll(`.branch.source-${d.node.id}`).select(\".branch-path\")\n            .classed(\"selected\",shouldSelect)\n\n        const sourceNodes = fig.layout.graph.getIncomingEdges(d.node).map(e=>e.source);\n        for(const source of sourceNodes){\n            const node =  fig.svgSelection.select(`.node.id-${source.id}`).select(\".node-shape\");\n            node.classed(\"selected source\", shouldSelect);\n            // on all other plots\n            selectAll(`.tip-${source.id}`).classed(\"selected source\", shouldSelect);\n            selectAll(`.id-${source.id} `).select(\".node-shape\").classed(\"selected source\", shouldSelect);\n            selectAll(`.tip-${source.id}`).select(\".branch-path\").classed(\"selected transmission\", shouldSelect);\n\n        }\n        const targetNodes = fig.layout.graph.getOutgoingEdges(d.node).map(e=>e.target);\n        for(const target of targetNodes){\n            const node =  fig.svgSelection.select(`.node.id-${target.id}`).select(\".node-shape\");\n            node.classed(\"selected transmission\", shouldSelect);\n            // on all other plots\n            selectAll(`.tip-${target.id}`).classed(\"selected transmission\", shouldSelect);\n            selectAll(`.id-${target.id}`).select(\".node-shape\").classed(\"selected transmission\", shouldSelect);\n            selectAll(`.tip-${target.id}`).select(\".branch-path\").classed(\"selected transmission\", shouldSelect);\n\n        }\n    }\n\n    const [figtree,setFigtree]=useState(null);\n\n    // const el = useCallback(node => {\n        \n        // if (node !== null) {\n            // if(node.children.length===0){ // make it the first time\n            const el = useRef();\n            useEffect(()=>{   \n            // const layout = new ArcLayout(props.graph,{xFunction:xfunc,curve:props.curve});\n                const settings = { hoverBorder: 4, backgroundBorder:2,\n                    baubles: [new CircleBauble()],\n                    tranitionDuration:0,\n                    opacityFunc:e=>e.data.metaData.support,\n                };\n                const fig = new FigTree(el.current,props.layout,props.margins,settings);\n            fig.draw();\n            // fig.onHover(callback,\".node\")\n            fig.onHoverNode(nodeCallback);\n            fig.onClickNode(nodeClick);\n            // fig.hilightBranches();\n            fig.onHoverBranch(branchCallback);\n            select(el.current).select(\".axes-layer\").remove();\n            setFigtree(fig);\n            // fig.update();\n            },[]);\n\n            useEffect(()=>{\n               if(figtree) figtree.update();\n            },[props.chartGeom.width,props.chartGeom.height])\n            // }        figtree.update();\n\n    \n\nconst rand_id = `b${Math.random().toString(36).substring(4)}`\n\n\n        return(\n            <svg className=\"chart\" id= {rand_id}\n            ref={el}\n            height={props.chartGeom.height}\n            width={props.chartGeom.width}\n        />);\n\n};\n\n\n\n\nexport default ArcTransmission;","import React, { useEffect,useRef } from 'react';\nconst ObjectChart = React.forwardRef((props,ref)=>{\n\n    return (\n        <svg className=\"chart\"\n        ref={ref}\n        height={props.chartGeom.height}\n        width={props.chartGeom.width}\n    />);\n});\nexport default  ObjectChart;","import {easeLinear} from 'd3-ease';\nimport {transition} from \"d3-transition\";\nimport {select} from 'd3-selection';\nimport {scaleLinear,scaleTime} from 'd3-scale';\nimport {axisBottom,axisTop} from \"d3-axis\";\nimport { d3Plot } from './d3Plot';\n/** \n * time Axis\n * settings \n */\nexport class XTimeAxis extends d3Plot{\n    static DEFAULT_SETTINGS() {\n      return {\n        transitionDuration:0,\n        horizontalRange:[0,1],\n        horizontalAxisTicks:[0,0.5,1],\n        horizontalScale:scaleLinear\n        }\n    }\n  /**\n   * The constuctor\n   * @param {*} domain array of first and last dates in axis\n   * @param {*} settings ticksUnit : timeWeek is default\n   */\n\nconstructor(svg,layout,margins,settings = { }){\n    super();\n    this.layout = layout;\n\n  this.settings = {...XTimeAxis.DEFAULT_SETTINGS(), ...settings};\n  // default ranges - these should be set in layout()\n  this._horizontalRange = this.settings.horizontalRange;\n  this.svg = svg;\n  this.margins = margins;\n  // To appease the \n}\ndraw(){\n       // get the size of the svg we are drawing on\n       let width,height;\n       if(Object.keys(this.settings).indexOf(\"width\")>-1){\n           width =this.settings.width;\n       }else{\n           width = this.svg.getBoundingClientRect().width;\n       }\n       if(Object.keys(this.settings).indexOf(\"height\")>-1){\n           height =this.settings.height;\n       }else{\n           height = this.svg.getBoundingClientRect().height;\n       }\n       //\n       this.scales={x:this.settings.horizontalScale()\n        .domain(this._horizontalRange)\n        .range([this.margins.left, width - this.margins.right-this.margins.left]),\n        width:width,\n        height:height}\n\n       //remove the tree if it is there already\n       select(this.svg).select(\"g\").remove();\n\n       // add a group which will contain the new plot\n       select(this.svg).append(\"g\")\n           .attr(\"transform\",`translate(${this.margins.left},${this.margins.top})`);\n        //to selecting every time\n        this.svgSelection = select(this.svg).select(\"g\");\n        this.svgSelection.append(\"g\").attr(\"class\", \"axes-layer\");\n        \n        this.svgSelection.select(\".axes-layer\")\n        .append(\"g\")\n        .attr(\"class\", \"top axis\")\n        .attr(\"id\", \"x-axis-top\")\n        .call(axisTop(this.scales.x).tickValues(this.layout.horizontalAxisTicks));\n\n        this.svgSelection.select(\".axes-layer\")\n        .append(\"g\")\n        .attr(\"transform\",`translate(0,${(this.scales.height-this.margins.bottom-this.margins.top-50)})`)\n        .attr(\"class\", \"bottom axis\")\n        .attr(\"id\", \"x-axis-bottom\")\n        .call(axisBottom(this.scales.x).tickValues(this.layout.horizontalAxisTicks));\n\n}\nupdate(){\n           // get the size of the svg we are drawing on\n           let width,height;\n           if(Object.keys(this.settings).indexOf(\"width\")>-1){\n               width =this.settings.width;\n           }else{\n               width = this.svg.getBoundingClientRect().width;\n           }\n           if(Object.keys(this.settings).indexOf(\"height\")>-1){\n               height =this.settings.height;\n           }else{\n               height = this.svg.getBoundingClientRect().height;\n           }\n           //\n        this.scales={x:this.settings.horizontalScale()\n                        .domain(this._horizontalRange)\n                        .range([this.margins.left, width - this.margins.right-this.margins.left]),\n                        width:width,\n                        height:height}\n\n        this.svgSelection.select(\"#x-axis-top\")\n                        .call(axisTop(this.scales.x).tickValues(this.layout.horizontalAxisTicks.map((x,i)=>i%2===0?x:\"\")))\n                        .transition()\n                        .duration(this.settings.transitionDuration)\n                        .ease(easeLinear);\n\n    this.svgSelection.select(\"#x-axis-bottom\")\n                        .attr(\"transform\",`translate(0,${(this.scales.height-this.margins.bottom-this.margins.top)})`)\n                        .call(axisBottom(this.scales.x).tickValues(this.layout.horizontalAxisTicks.map((x,i)=>i%2===0?x:\"\")))\n                        .transition()\n                        .duration(this.settings.transitionDuration)\n\n\n                        this.updateAxisBars();\n}\n\n\nget horizontalRange(){\n    return this._horizontalRange;\n}\n}\nexport default XTimeAxis;","import React, {useCallback,useState} from 'react';\nimport {XTimeAxis} from '../lib/charts/axis';\nimport {scaleTime} from \"d3-scale\"\nimport {extent} from 'd3-array';\nfunction TimeAxis(props){\n    const [axis,Setaxis]=useState(null);\n    \n    const el = useCallback(node => {\n        \n        if (node !== null) {\n            if(node.children.length===0){ // make it the first time\n                const layoutSettings = {horizontalRange:extent(props.dateRange),\n                    horizontalAxisTicks:props.dateRange,\n                    horizontalScale:scaleTime,\n                tranitionDuration:0};\n                    const margins = {...props.margins,...{top:30,bottom:25}};\n                const fig = new XTimeAxis(node,layoutSettings, margins,layoutSettings);\n                fig.draw();\n                Setaxis(fig);\n            }else{\n                axis.update();\n            }\n        }\n    });\nconst rand_id = `b${Math.random().toString(36).substring(4)}`\n\n\n        return(\n            <svg id= {rand_id} \n            ref={el}\n            height={props.domRect.height+20+20+20}// 10px padding timecontainer 10px margin on chart 20px top margin on this 20 px bottom here\n            width={props.chartGeom.width}\n        />);\n\n};\n\nexport default TimeAxis;\n","import React, {useState,useCallback,useEffect} from 'react';\nimport{max} from 'd3-array';\nimport StackedHistogram from './StackedHistogram';\n// import ArcTransmission from \"./ArcTransmission\";\nimport PhyloChart from './PhyloChart';\nimport AreaPlot from './AreaPlot';\nimport ArcTransmission from './ArcTransmission';\nimport TimeAxis from './TimeAxis';\nimport { RectangularLayout, TransmissionLayout } from '../lib/figtree.js/index.js';\n\nimport 'react-perfect-scrollbar/dist/css/styles.css';\nimport PerfectScrollbar from 'react-perfect-scrollbar'\nimport {event, select} from \"d3-selection\";\n\n// callbacks for the vertical timeline bar\nconst mouseEnter = (event, i, n)=>{\n    // console.log(event)\n    let timeline = document.getElementById(\"timeline\");\n    if (event.altKey) {\n        timeline.style.left = event.pageX + \"px\";\n        timeline.style.transition = \"none\";\n        timeline.style.opacity = \"1\";\n        timeline.style.visibility =\"visible\";\n    } else {\n        // -webkit-transition: 0.5s;\n        // -moz-transition: 0.5s;\n        // -o-transition: 0.5s;\n        // transition: 0.5s;\n        timeline.style.transition = \"0.5s\";\n        timeline.style.opacity = \"0\";\n        timeline.style.visibility = \"hidden\";\n    }\n};\n\nconst mouseExit = (d,i,n) => {\n    const timeline = document.getElementById(\"timeline\");\n    timeline.style.visibility = \"hidden\";\n};\n\nconst ChartContainer = React.forwardRef((props, ref)=>{\n\n\n    const [chartGeom,setChartGeom]=useState({height:300,width:1200});\n    const margins = {\"top\":10,\"bottom\":10,\"left\":50,\"right\":50};\n\n    //Update chart sizes\n    useEffect(()=>{\n        if(props.timelineSize!==null){\n            const parentBaseDim={\"height\":300,\"width\":props.timelineSize.width*0.94};\n            setChartGeom(parentBaseDim)\n        }\n\n    },[props.timelineSize]);\n\n    //Ensure we don't render before we have scales ect.\n    const isFull = Object.values(props)\n        .every(x => (x !== null & x !== ''));\n\n    if(!isFull){\n        return(\n            <div className = \"timelineContainer\" ref={ref}>\n            </div>\n        )\n    }else{\n        console.log(\"reRender\")\n\n        return(\n            <div className = \"timelineContainer\" ref={ref} onMouseMove={mouseEnter} onMouseLeave={mouseExit}>\n                <div id=\"timeline\"></div>\n                <div className=\"hoverInfo\" id=\"tooltip\"></div>\n                <div className = \"mockChartContainer\">\n                    <TimeAxis dateRange ={props.dateRange}\n                              margins = {margins}\n                              chartGeom = {chartGeom}\n                              domRect = {props.timelineSize}/>\n                </div>\n                <div className = \"chartContainer\">\n                    <StackedHistogram  data={props.epidemic.Cases}\n                                       margins = {margins}\n                                       layout = {props.stackedLayout}\n                                       chartGeom={chartGeom}\n                                       dateRange ={props.dateRange}\n                                       callbacks={{groups:d=>d.location}}/>\n                    <div className=\"chartTitle\">Case plot</div>\n                </div>\n                <div className = \"chartContainer\">\n                    <AreaPlot\n                        layout ={props.areaLayout}\n                        selectArea ={props.selectArea}\n                        margins = {margins}\n                        epidemic={props.epidemic}\n                        dateRange ={props.dateRange}\n                        chartGeom={{...chartGeom,...{\"height\":400}}}/>\n                    <div className=\"chartTitle\">Outbreaks</div>\n                </div>\n                <div className = \"chartContainer\">\n                    <ArcTransmission\n                        margins = {margins}\n                        treeDateRange={props.treeDateRange}\n                        phylogeny={props.phylogeny}\n                        graph={props.epidemic.graph}\n                        dateRange ={props.dateRange}\n                        curve ={\"bezier\"}\n                        layout ={props.transmissionLayout}\n                        chartGeom={chartGeom}\n                        setSelectedCases={props.setSelectedCases}\n                        selectedCases={props.selectedCases}/>\n                    <div className=\"chartTitle\">Case connections</div>\n                </div>\n                <div className = \"chartContainer\">\n                    <PhyloChart\n                        margins = {margins}\n                        dateRange ={props.dateRange}\n                        treeDateRange={props.treeDateRange}\n                        phylogeny={props.phylogeny}\n                        layout = {RectangularLayout}\n\n                        // attributes = {phyloAttributes}\n                        chartGeom={{...chartGeom,...{\"height\":600}}}/>\n                    <div className=\"chartTitle\">Transmission tree</div>\n        </div>\n            </div>\n        )}\n    // <Chart  />\n});\n\nexport default  ChartContainer;\n","import React, {useState,useCallback,useRef} from 'react';\nimport ReactTable from 'react-table';\nimport {timeFormat} from \"d3\"\nconst formatTime = timeFormat(\"%B %d, %Y\");\n\nfunction LineList(props){\n\n\n       \n        const columns = [{\n          id:\"id\",\n          Header: 'Case Id',\n          accessor: d=>d.id ,\n        },{\n          id:\"location\",\n          Header:'Location',\n          accessor: d=>d.location\n      },{\n        id:\"symptomOnset\",\n        Header:'Symptom Onset',\n        accessor: d=>d.symptomOnset,\n        Cell:props => props.value===null? <span>Unknown</span>:<span>{formatTime(props.value)}</span>,\n        filterable: false  //This makes the column not filterable\n\n      }]\n\n      const potentialSourcesColumns = [{\n        id:\"source\",\n        Header: 'Source',\n        accessor: d=>d.source.id \n      },\n      {\n        id:\"dataSource\",\n        Header: 'Data Source',\n        accessor: d=>d.metaData.dataSource\n      },\n      {\n        id:\"support\",\n        Header: 'Support',\n        accessor: d=>d.metaData.support\n      }]\n\n      const potentialTransmissionsColumns = [{\n        id:\"target\",\n        Header: 'Target',\n        accessor: d=>d.target.id \n      },\n      {\n        id:\"dataSource\",\n        Header: 'Data Source',\n        accessor: d=>d.metaData.dataSource\n      },\n      {\n        id:\"support\",\n        Header: 'Support',\n        accessor: d=>d.metaData.support\n      }]\n\n\n      const subtableHeader = {\n        display:'inline-block',\n        marginRight:'10px',\n        marginLeft:'10px'\n\n\n      }\n\n\n\n      const rows =props.epidemic.Cases.length;\n       const selectedData = props.selectedCases.length>0?props.epidemic.Cases.filter(n=>props.selectedCases.map(s=>s.id).indexOf(n.id)>-1):props.epidemic.Cases;\n        return (\n        <ReactTable\n          showPagination={false}\n          defaultPageSize={rows}\n          data={selectedData}\n          columns={columns}\n          filterable\n          className=\"-striped -highlight\" // add styles\n          SubComponent={row => {\n            const inlinks = props.epidemic.graph.getIncomingEdges(row.original)\n            const outlinks = props.epidemic.graph.getOutgoingEdges(row.original)\n\n            return(\n            <div>\n              <div style={subtableHeader}className={\"legendSquare source\"}></div>\n              <div style={subtableHeader}><h4> Putative sources of infection </h4> </div>\n              <ReactTable\n            showPagination={false}\n            defaultPageSize={inlinks.length}\n            data={inlinks}\n            // filterable\n            className=\"-striped -highlight\" // add styles\n            columns={potentialSourcesColumns}/>\n              <div style={subtableHeader}className={\"legendSquare  transmission\"}></div>\n              <div style={subtableHeader}><h4> Putative Transmissions </h4> </div>            <ReactTable\n            showPagination={false}\n            defaultPageSize={outlinks.length}\n            data={outlinks}\n            // filterable\n            className=\"-striped -highlight\" // add styles\n            columns={potentialTransmissionsColumns}/>\n            </div>)\n          }}\n\n        />)\n}\n\nexport default LineList;","import React, {props, useRef, useState} from 'react';\nimport {event, select, selectAll} from \"d3\";\nimport {geoAzimuthalEqualArea, geoPath} from \"d3-geo\";\nimport {feature} from \"topojson\";\n\nconst mouseEnter = (d, i, n)=>{\n    select(n[i]).classed(\"hovered\", true);\n    // console.log(d)\n    let tooltip = document.getElementById(\"tooltip\");\n    // put text to display here!\n    tooltip.innerHTML =`Location: ${d.data.location}\n                        <br/>\n                        Cases: 0`;\n\n    tooltip.style.display = \"block\";\n\n    // this should be dynamically set (i.e., the tooltip box should always be aligned to\n    // be visible in the view port).\n    tooltip.style.left = event.pageX + (event.pageX > 800? -300 : + 10) + \"px\";\n    tooltip.style.top = event.pageY + 10 + \"px\";\n\n    tooltip.style.visibility =\"visible\";\n};\n\nconst mouseExit = (d,i,n) => {\n    select(n[i]).classed(\"hovered\", false);\n    const tooltip = document.getElementById(\"tooltip\");\n    tooltip.style.visibility = \"hidden\";\n};\n\nfunction Geography(props){\n    const [map, setMap] = useState(null);\n\n    const width = props.size.width;\n    const height = props.size.height;\n    const mapData = props.data;\n\n    // center on UK\n    // const projection = geoAzimuthalEqualArea()\n    //     .center([-4, 54.5])\n    //     .scale(3000)\n    //     .translate([width / 2, height / 2]);\n\n    // center on DRC\n    // const projection = geoAzimuthalEqualArea()\n    //     .center([29.0460, 0.7918])\n    //     .scale(4000)\n    //     .translate([width / 2, height / 2]);\n\n  \n\n    // const zoom = d3.behavior.zoom()\n    //     .translate(projection.translate())\n    //     .scale(projection.scale())\n    //     .scaleExtent([height, 8 * height])\n    //     .on(\"zoom\", zoomed);\n\n    const adm0 = feature(mapData, mapData.objects.adm0);\n    const adm1 = feature(mapData, mapData.objects.adm1);\n    let adm2 = mapData.objects.adm2? feature(mapData, mapData.objects.adm2):null;\n    let projection;\n    let path;\n    if(adm0.features.map(m=>m.id).indexOf(\"UGA\")>-1){\n        projection= geoAzimuthalEqualArea()\n        .center([29.0460, 0.7918])\n        .scale(4000)\n        .translate([width / 2, height / 2]);\n\n    }else{\n        projection = geoAzimuthalEqualArea()\n        .center([-4, 54.5])\n        .scale(3000)\n        .translate([width / 2, height / 2]);\n\n    }\n    path = geoPath()\n    .projection(projection);\n\n    // console.log(\"ADM1: \" + JSON.stringify(path(adm1.features[24])));\n\n    const el = useRef();\n\n    // if (el.current !== null) {\n\n\n    //to selecting every time\n    const svg = select(el.current);\n\n    const g = svg.append(\"g\");\n        // .call(zoom);\n\n    g.append(\"rect\")\n        .attr(\"class\", \"map-background\")\n        .attr(\"width\", width)\n        .attr(\"height\", height);\n\n    g.append(\"g\")\n        .attr(\"id\", \"adm0\")\n        .selectAll(\"path\")\n        .data(adm0.features)\n        .enter().append(\"path\")\n        .attr(\"class\", \"adm0\")\n        .attr(\"id\", (d) => d.properties.name.replace(\" \", \"-\"))\n        .attr(\"d\", path);\n\n    g.append(\"g\")\n        .attr(\"id\", \"adm1\")\n        .selectAll(\"path\")\n        .data(adm1.features)\n        .enter().append(\"path\")\n        .attr(\"class\", \"adm1\")\n        .attr(\"id\", (d) => d.properties.name.replace(\" \", \"-\"))\n        .attr(\"d\", path);\n\n        if(adm2){\n    g.append(\"g\")\n        .attr(\"id\", \"adm2\")\n        .selectAll(\"path\")\n        .data(adm2.features)\n        .enter().append(\"path\")\n        .attr(\"class\", \"adm2\")\n        .attr(\"id\", (d) => d.properties.name.replace(\" \", \"-\"))\n        .attr(\"d\", path);\n        }\n\n    // }else{\n    //     update?\n\n\n\n    return(\n        <svg className=\"chart\" id={\"map\"}\n             ref={el}\n             height={props.size.height}\n             width={props.size.width}\n        />);\n}\n\nexport default Geography;","import * as d3 from 'd3';\nimport {nest} from \"d3-collection\";\n\nconst  parseDate = d3.timeParse(\"%Y-%m-%d\")\n\n\nexport const  parseCaseData=(d)=>{\n    const standardColumns =[\"Id\",\"Date of sampling\"]\n    const entry = {\n        id:d['Id'],\n        dateOfSampling:parseDate(d['Date of sampling']),\n        metaData:{},\n    }\n        Object.keys(d).forEach(name=>{\n            if(standardColumns.indexOf(name)===-1){\n                if(name.toLowerCase().indexOf(\"date\")>-1){\n                    entry.metaData[name]=parseDate(d[name]);\n                }else{\n                   entry.metaData[name]=d[name];\n                }\n            }\n    });\n    return entry;\n}\n\nexport const parseEdgeData=(d)=>{\n    const standardColumns =[\"Source\",\"Target\"]\n    const entry = {\n        source:d['Source'],\n        target:d['Target'],\n        metaData:{},\n    }\n\n        Object.keys(d).forEach(name=>{\n            if(standardColumns.indexOf(name)===-1){\n                entry.metaData[name]=d[name];\n            }\n    });\n    return entry;\n}\nexport const readData =(fileName,formatter,callback)=>{\n        d3.csv(fileName,(data)=>{\n                const parsedData = data.map(d=>formatter(d));\n                callback(parsedData);\n\n      });\n}\n/**\n * This function takes an array of Link objects in source,target,dataSource\n * and returns a link for each source, target pair with a metadata entry for the dataSource and\n * the proportion of links of the that data source and target that have the given source.\n * @param {array of Links} links \n */\nexport const summarizeLinks=(links)=>{\n    const nestLinks = nest()\n    .key(d=>d.target)\n    .key(d=>d.source)\n    .key(d=>d.dataSource)\n    .entries(links)\n\n    const dataSources= [];\n    links.forEach(l => {\n        dataSources.indexOf(l.dataSource)===-1 && dataSources.push(l.dataSource);\n    });\n// nested links is [ {key: target, values:[{key:source,values:[{key:dataSource, values: [links]}] }]}]\n    const summarizeLinks =[];\n    for(const l of nestLinks){\n        const target = l.key;\n        const totalObservations ={};\n        for(const ds of dataSources){\n            totalObservations[ds] = l.values.map(s=>s.values.filter(d=>d.key===ds)) // array of array of {key:soures, value:data} with an entry for each source\n                                                    .reduce((acc,curr)=>{  // flatten array above\n                                                        return acc.concat(curr)\n                                                    },[])\n                                                    .reduce((acc,curr)=>acc+curr.values.length,0); // sum number of data points \n                                                                    // .reduce((acc,curr)=>acc+curr.values.length,0)));\n        }\n        // totalObservations is { datasource: #obervations that have this source }\n            // for each source\n            for(const s of l.values){\n                const source = s.key;\n\n                for(const ds of s.values){ // s.values is an array of {key:datasource, values: links }\n                //    const data=ds.values;\n                const metaData ={};\n                metaData[\"dataSource\"] = ds.key;\n                metaData[\"support\"] = ds.values.length/totalObservations[ds.key]\n                summarizeLinks.push({\"target\":target,\"source\":source,\"metaData\":metaData})\n                }\n\n\n                \n            }\n\n        }\n        return(summarizeLinks);\n}\n\n","import React, {useState,useCallback,useEffect} from 'react';\nimport {csv} from \"d3-fetch\";\nimport Case from \"../lib/outbreak/Case\";\nimport Link from \"../lib/outbreak/Link\";\nimport {dateParse,mode} from \"../utils/commonFunctions\"\nimport {scaleTime,scaleLinear} from 'd3-scale';\nimport {timeWeek,timeDay} from \"d3-time\";\nimport {max,min,extent} from \"d3-array\";\nimport {nest} from \"d3-collection\"\nimport Header from './Header';\nimport ChartContainer from './ChartContainer';\nimport LineList from \"./LineList\";\n\n// icons\nimport { IoIosSettings } from \"react-icons/io\";\nimport { IoIosMap } from \"react-icons/io\";\nimport { IoIosListBox } from \"react-icons/io\";\n\nimport Geography from \"./Geography\"\nimport {Epidemic} from \"../lib/outbreak/Epidemic\";\nimport { Graph,Tree} from '../lib/figtree.js/index.js';\nimport {summarizeLinks} from '../utils/dataParsers.js'\n\n\nimport{stackedHistogramLayout} from \"../lib/charts/stackedHistogramLayout\"\nimport{fishLayout} from \"../lib/charts/fishplotLayout\"\nimport{ArcLayout} from \"../lib/figtree.js/arcLayout\"\n\nimport 'react-table/react-table.css';\nimport \"../styles/trapper.css\"\n\n\nfunction App() {\n    /*----------- Managing option bars and sizes \t------------------*/\n\n    const [optionsOpen,setOptionsOpen] = useState(false);\n    const [sideBarOpen,setSideBarOpen] = useState(false);\n    const [timelineSize,getTimelineSize] = useState(null);\n    const [sideBarFocus,setSideBarFocus] = useState(\"Geography\");\n    //Getting the size of the container to pass to children\n    // const [handleResize,setHandelResize] = useState(null);\n    // const otherRef = useRef(null);\n    const measuredRef = useCallback(node => {\n        if (node !== null) {\n            getTimelineSize({\"height\":node.getBoundingClientRect().height,\"width\":node.getBoundingClientRect().width})\n            const handleResize = () =>  {\n                let resizeTimer;\n                clearTimeout(resizeTimer);\n                resizeTimer = setTimeout(function() {\n\n                    // Run code here, resizing has \"stopped\"\n                    getTimelineSize({\"height\":node.getBoundingClientRect().height,\"width\":node.getBoundingClientRect().width});\n                }, 250);\n            }\n\n            window.addEventListener('resize', handleResize);\n            return () => {\n                window.removeEventListener('resize', handleResize);\n            };\n        }\n    },[]);\n    const getSizeAgain=()=>{\n        let resizeTimer;\n        clearTimeout(resizeTimer);\n        resizeTimer = setTimeout(function() {\n            window.dispatchEvent(new Event('resize'))\n        },0); // resize takes 0.4s\n    };\n\n    /*----------------------- Data management----------------------------------*/\n    const prefix = process.env.NODE_ENV === 'development' ? 'http://localhost:4001' : 'https://raw.githubusercontent.com/jtmccr1/trapper/master/examples/simulated';\n\n    //------------ Data processing ------------------------\n\n    // hardcoding in data processing - magic number\n\n\n    const [phylogeny,setPhylogeny] = useState(null);\n    const [dateRange,setDateRange] = useState(null)\n    const [epidemic,setEpidemic] = useState(null);\n    const [treeDateRange,setTreeDateRange] = useState(null);\n    const [mapTopoJSON,setMapTopoJSON] =useState(null);\n    const [selectedCases,setSelectedCases] = useState([]);\n    const [areaLayout,setAreaLayout] = useState(null);\n    const [transmissionLayout,setTransmissionLayout] = useState(null)\n    const[stackedLayout,setStackedLayout] = useState(null);\n    const [setArea,setAreaFunc] = useFunctionAsState(()=>console.log(\"test\"))\n    //Load the data at the start\n    useEffect(()=>{\n        console.log(\"reading in the data\")\n        // read in lineList, links,tree,treeAnnotations\n        Promise.all([csv(`${prefix}/lineList.csv`),csv(`${prefix}/links.csv`),fetch(`${prefix}/tree.nwk`),fetch(`${prefix}/treeAnnotations.json`)])\n            .then(([lineList,links,treeStringPromise,treeAnnotationsPromise])=>{\n                // Make the graph object that connects the casea and links\n                const parsedLineList = lineList.map(d=>{\n                    const dataPoint = {\n                        id:d.id,\n                        symptomOnset:dateParse(d.symptomOnset),\n                        sampleDate:[dateParse(d.sampleDate)],\n                        location:d.location,\n                        resolution:d.Outcome,\n                    }\n                    return new Case(dataPoint);\n                })\n                const parsedLinks = links.map(d=>new Link(d));\n                //todo link for each datatype\n                let summarizedLinks = summarizeLinks(parsedLinks);\n                // get and source cases that weren't in the line list ie the unsampled root;\n                const sources =  summarizedLinks.map(l=>l.source).reduce((acc,curr)=>{\n                    if(acc.indexOf(curr)===-1){\n                        return(acc.concat(curr));\n                    }\n                    return(acc);\n                },[]);\n                const targets =  summarizedLinks.map(l=>l.target).reduce((acc,curr)=>{\n                    if(acc.indexOf(curr)===-1){\n                        return(acc.concat(curr));\n                    }\n                    return(acc);\n                },[]);\n                const cases = [...parsedLineList];\n                for(const source of [...sources,...targets]){\n                    if(cases.filter(d=>d.id===source).length===0){\n                        console.log(`${source} present in links but not lineList all links are removed`)\n                        if(source.includes(\"root\")){\n                        const newCase = new Case({\"id\":source});\n                        cases.push(newCase);\n                        }else{\n\n                        \n                        // remove the link if the case is not in the line list\n                        summarizedLinks= summarizedLinks.filter(l=>l.source!==source);\n                        summarizedLinks= summarizedLinks.filter(l=>l.target!==source);\n                    }\n                }\n            }   // filtering the links that have low support\n                const filtedLinks=summarizedLinks.filter(l=>l.metaData.support>0.02);\n                //The graph!\n                const outbreakGraph = new Graph(cases,filtedLinks);\n                const indexCase = outbreakGraph.nodes.find(n=>outbreakGraph.getOutgoingEdges(n).length>0&&outbreakGraph.getIncomingEdges(n).length===0);\n                if(indexCase.location===\"Unknown\"){\n                    // Sets index location to most common location of children\n                    indexCase.symptomOnset=null;\n                    const childLocations = outbreakGraph.getOutgoingEdges(indexCase)\n                        .filter(e=>mostProbableTransphyloEdgeCondition(outbreakGraph)(e))\n                        .map(e=>e.target.location)\n                    indexCase.location = mode(childLocations);\n                }\n                const outbreakEpidemic = new Epidemic(indexCase,outbreakGraph,mostProbableTransphyloEdgeCondition);\n                setEpidemic(outbreakEpidemic);\n\n                // Handle the Tree\n                Promise.all([treeStringPromise.text(),treeAnnotationsPromise.json()])\n                    .then(([treeString,treeAnnotations])=>{\n                        //Todo annotate Tree.\n                        const tree = Tree.parseNewick(treeString);\n                        //locations from tips\n                        \n                        tree.annotateNodesFromLabel(treeAnnotations);\n                        \n                        // if there are no locations in the annotations we do one from the tips.\n                        if(!tree.annotations.hasOwnProperty(\"location\")){\n                        const tipLocations={};\n                        parsedLineList.forEach(t=>{tipLocations[t.id]={location:t.location}})\n                        tree.annotateTips(tipLocations)\n                        tree.annotateNodesFromTips(\"location\")\n                        }\n                        tree.order();\n                        setPhylogeny(tree);\n                        // get initial time range\n                        const casesRange = extent(outbreakGraph.nodes,d=>d.symptomOnset);\n                        const treeMaxTipLength = max(tree.nodes,n=>tree.rootToTipLength(n));\n\n                        const treeMaxTip = tree.nodes.find(n=>tree.rootToTipLength(n)===treeMaxTipLength);\n                        const treeMaxDate = max(outbreakGraph.getNode(treeMaxTip.name).sampleDate); // names must match case id's in line list; sampleDate is an array.\n\n                        const treeRootDate = timeDay.offset(treeMaxDate,(-1*treeMaxTipLength*365)); // not exact\n                        const totalExtent = extent([treeRootDate,...casesRange,treeMaxDate]);\n                        const week0 = timeWeek.offset(timeWeek.floor(totalExtent[0]),-1);\n                        // add an extra one for the range function [,)\n                        const weekEnd = timeWeek.offset(timeWeek.ceil(totalExtent[1]),2);\n                        setDateRange(timeWeek.range(week0,weekEnd));\n                        setTreeDateRange([treeRootDate,treeMaxDate]);\n                    // layouts\n                        const layoutSettings = {\n                            horizontalRange:extent(timeWeek.range(week0,weekEnd)),\n                            horizontalTicks:timeWeek.range(week0,weekEnd),\n                            horizontalScale:scaleTime,\n                            groupingFunction:d=>d.location};\n                            // setLayoutSettings(layoutSettings)\n                            setStackedLayout( new stackedHistogramLayout(outbreakEpidemic.Cases,layoutSettings));\n                        \n                            setAreaLayout(new fishLayout(outbreakEpidemic,layoutSettings))\n                            const xScale = scaleTime().domain(layoutSettings.horizontalRange).range([0,1]); // pass in date domain\n                            const xfunc=(n,i)=>n.id===\"UnsampledrootCase\"? xScale(treeRootDate[0]):xScale(n.symptomOnset) // for setting the x postion;\n                        \n                    \n                            // const selectAreaFact=()=>{\n                                const selectArea=(epidemic)=>{\n                                setEpidemic(epidemic);\n                                setStackedLayout( new stackedHistogramLayout(outbreakEpidemic.Cases,layoutSettings));\n                                setAreaLayout(new fishLayout(outbreakEpidemic,layoutSettings))\n                                const xScale = scaleTime().domain(layoutSettings.horizontalRange).range([0,1]); // pass in date domain\n                                const xfunc=(n,i)=>n.id===\"UnsampledrootCase\"? xScale(treeRootDate[0]):xScale(n.symptomOnset) // for setting the x postion;\n                            \n                                setTransmissionLayout( new ArcLayout(outbreakEpidemic.graph,{xFunction:xfunc,curve:'bezier'}));\n                                }\n\n                            // }\n                            setAreaFunc(selectArea)\n                            setTransmissionLayout( new ArcLayout(outbreakEpidemic.graph,{xFunction:xfunc,curve:'bezier'}));\n\n                        })\n\n\n            })\n        // get map\n        fetch(`${prefix}/map.json`).then(mapResponse=>mapResponse.json()).then(mapJSON=>setMapTopoJSON(mapJSON))\n\n    },[])\n\n\n// Set the epidemic data\n    function mostProbableTransphyloEdgeCondition(graph){\n        const actualFilterFunction = (edge)=>{\n            const target = edge.target;\n            // get incoming edges\n            const incomingEdges = graph.getIncomingEdges(target);\n            const maxTransphyloProb = max(incomingEdges.filter(e=>e.metaData.dataSource===\"transphylo\"), e =>e.metaData.support);\n            return (edge === incomingEdges.find(e=> e.metaData.dataSource===\"transphylo\" && e.metaData.support===maxTransphyloProb))\n        }\n        return actualFilterFunction\n    }\n    const mapMargins = {\"top\":5,\"bottom\":5,\"left\":5,\"right\":5};\n    const mapSize = {\"height\": 500, width: 500};\n\n\n\n    //    layouts\n\n\n    /*---------------------- Rendering -------------------------*/\n\n    return(\n        <div className=\"fillHorizontalSpace\">\n            <Header />\n            <div className=\"mainScreen\">\n                <div className={`sidebar left ${optionsOpen? \"open\":''}`}>\n                </div>\n                <div className=\"sidebarButtonColumn\">\n                    \n                    <div className=\"sidebarButtons left\">\n                        <h3 className=\"button\" onClick={()=> {setOptionsOpen(!optionsOpen);getSizeAgain();}}>\n                            <div className=\"button-icon\"><IoIosSettings/></div>\n                            <div className=\"rotate-plus-ninety\">Options</div>\n                        </h3>\n                    </div>\n                </div>\n                <ChartContainer\n                    ref = {measuredRef}\n                    timelineSize = {timelineSize}\n                    dateRange={dateRange}\n                    treeDateRange={treeDateRange}\n                    epidemic={epidemic}\n                    phylogeny={phylogeny}\n                    stackedLayout={stackedLayout}\n                    areaLayout={areaLayout}\n                    transmissionLayout = {transmissionLayout}\n                    setSelectedCases={setSelectedCases}\n                    selectedCases={selectedCases}\n                    selectArea={setArea}/>\n                <div className=\"sidebarButtonColumn\">\n                    <div className=\"sidebarButtons right\">\n                        <h3 className={`button ${sideBarOpen && sideBarFocus === \"Geography\" ? \"selected\" : \"\"}`} onClick={()=> {\n                            if(sideBarOpen&&sideBarFocus!==\"Geography\"){\n                                setSideBarFocus(\"Geography\")\n                            }else{\n                                setSideBarOpen(!sideBarOpen)\n                                setSideBarFocus(\"Geography\")\n                            }\n                            getSizeAgain();\n                        }}>\n                            <div className=\"button-icon\"><IoIosMap/></div>\n                            <div className=\"button-text rotate-minus-ninety\">Map</div>\n                        </h3>\n\n                        <h3 className={`button ${sideBarOpen && sideBarFocus === \"LineList\" ? \"selected\" : \"\"}`} onClick={()=> {\n                            if(sideBarOpen && sideBarFocus !== \"LineList\"){\n                                setSideBarFocus(\"LineList\")\n                            }else{\n                                setSideBarOpen(!sideBarOpen)\n                                setSideBarFocus(\"LineList\")\n                            }\n                            getSizeAgain();\n                        }}>\n                            <div className=\"button-icon\"><IoIosListBox/></div>\n                            <div className=\"button-text rotate-minus-ninety\">Line List</div>\n                        </h3>\n                    </div>\n                </div>\n                <div className={`sidebar right ${sideBarOpen? \"open\":''}`}>\n                    {sideBarFocus===\"Geography\"?\n                        <div className = \"geographyContainer\">\n                            {mapTopoJSON?\n                                <Geography data={mapTopoJSON} margins={mapMargins} size={mapSize} />\n                                :<h3>Loading Map</h3>}\n                        </div>\n                        :<LineList epidemic= {epidemic} selectedCases={selectedCases}/>}\n                </div>\n            </div>\n        </div>\n    )\n}\n//https://github.com/facebook/react/issues/14087\nfunction useFunctionAsState(fn) {\n\n    const [val, setVal] = useState(() => fn);\n  \n    function setFunc(fn) {\n      setVal(() => fn);\n    }\n  \n    return [val, setFunc];\n    \n  }\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA.\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      if (\n        response.status === 404 ||\n        response.headers.get('content-type').indexOf('javascript') === -1\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n// import './styles/index.css';\nimport App from './components/App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}